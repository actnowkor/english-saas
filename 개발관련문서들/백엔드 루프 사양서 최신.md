# 1) “백엔드 루프 자동화 함수 사양서” — 최신본

> 아래는 **문서 완성본**입니다. (새 함수 기준으로 전면 갱신)
> 기존 문서의 원칙·스냅샷·SRS 루프를 유지하면서 출제 단계만 확장했습니다.&#x20;

## 0) 원칙

* 모든 함수는 **SQL Editor → Function**으로 생성/관리.
* 프론트(API)는 **함수만 호출**하면 됨.
* **스냅샷 원칙**: 출제 시 `session_items.snapshot_json`에 문제·정답·변형·오답예시를 동결하고, **채점·복원은 반드시 스냅샷 기준**으로 수행.&#x20;
* **라이트너 규칙**(문장=concept, phrase/단어=item):

  * Box1=당일, Box2=+1d, Box3=+3d, Box4=+7d, Box5=+14d
  * 맞음(correct/variant) → box+1(최대5), 틀림(wrong/near\_miss) → box=1.&#x20;

---

## 1) 세션 시작(출제) — `start_session_custom`

**시그니처**
`start_session_custom(p_user_id uuid, p_type session_type, p_count int default null) returns uuid`

**설명**

* 정책 테이블(`policy_level_mix`, `policy_type_weights`, `policy_thresholds`)을 읽어 **타입/레벨믹스/임계**를 적용하고, 출제된 아이템을 **스냅샷 동결**한 뒤 `session_id`를 반환.

**규칙 요약**

* **임계 가드**: 레벨별 누적 풀이가 정책 임계(기본 300) 미만이면 자동 `new_only` 강제.
* **타입 비율**:

  * `new_only`: new=100%
  * `mix`: review=50%, new=30%, weak=20%
  * `review_only`: review=80%, weak=20%
  * `weak_focus`: weak=60%, new=40%
* **레벨 믹스**: 현재 레벨 중심 + 인접 레벨 소량. 재고 없는 레벨은 0% 처리 후 **정규화**.
* **선발 우선순위**: 카테고리 내에서 **due 우선**(복습), 약점은 `wrong_count`/`last_result` 기반.
* **전략 기록**: `sessions.strategy_json`에 `type/targets/level_mix/underfilled/filled` 저장(운영·리포트·재현성).
* **보안**: `SECURITY DEFINER` + `search_path=public`.

> 기존 `start_session(p_user_id, p_count)`는 “최신 item 기준 단순 출제”로, **신규 함수로 대체/병행**합니다. (하위호환이 필요하면 기존 함수는 유지)&#x20;

---

## 2) 답안 제출 — `submit_attempt`

* **입력**: `session_id, item_id, answer_raw, latency_ms`
* **출력**: `attempt_id`
* **비고**: 제출은 여러 번 허용 가능(실제 정책에 따라 UI에서 제어).&#x20;

---

## 3) 채점 저장 — `save_grade`

* **입력**: `attempt_id, label(correct|variant|near_miss|wrong), feedback_short, minimal_rewrite, error_tags[], judge(rule|ai), evidence_json`
* **출력**: void(UPSERT)
* **비고**: MVP는 **룰 채점 고정**(AI는 `needs_ai` 시 후처리 Stub).&#x20;

---

## 4) 라이트너 갱신 — `update_srs`

* **입력**: `p_session_id`
* **작동**: 세션 내 `attempts + grades`를 읽어 **item/concept SRS**를 갱신(상/하향, interval, next\_due\_at 등).
* **출력**: void
* **비고**: 채점 후 호출(즉시 또는 배치). 규칙 테이블은 기존 값 유지(0/1/3/7/14d).&#x20;

---

## 5) 세션 완료 — `complete_session`

* **입력**: `p_session_id`
* **작동**: `sessions.status='completed'`, `ended_at` 기록. 필요 시 간단 요약 통계를 추가 저장.
* **비고**: 히스토리/대시보드에서 사용.&#x20;

---

## 6) API 계약(요약)

* `POST /sessions` → **`start_session_custom` RPC**: `{ user_id, type, count }` → `{ session_id, items[], strategy{} }`
* `POST /attempts` → `submit_attempt`
* `POST /grades` → `save_grade`
* `POST /srs/update` → `update_srs`
* `POST /sessions/:id/complete` → `complete_session`
* **주의**: 채점은 항상 **스냅샷 기준**. 이력의 재풀기는 **연습 전용**(attempts/grades/SRS 미기록).&#x20;

---

## 7) RLS/권한

* `session_items` **직접 insert 금지** — 반드시 **SECURITY DEFINER 함수**로만 생성.
* 정책 테이블은 **읽기(SELECT) 허용, 쓰기(service\_role 전용)**.
* 함수는 `search_path=public` 명시. (권한·재현성 수칙은 현행 유지)&#x20;

---

### 한 줄 요약

* **출제 단계만 고도화**(정책 기반)했고, 나머지 루프(제출→채점→SRS→완료)는 기존 사양을 그대로 사용합니다.
* 프론트는 **타입/문항수만** 넘기고, 나머지는 DB가 처리합니다. (운영 변경은 **정책 테이블 값 수정만**으로 즉시 반영)&#x20;

원하면, 기존 `start_session`를 **래퍼**로 남겨 `start_session_custom`를 내부 호출하게 만드는 호환 버전도 바로 적어드릴게요.
