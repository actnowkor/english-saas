Supabase RLS 정책 사양서

완전 맞아요. **RLS 정책을 문서화**해두면 나중에 수정·디버깅·협업·보안리뷰가 압도적으로 편해집니다.
바로 가져다 쓸 수 있게 \*\*“RLS 정책 사양서(템플릿 + SQL + 점검 체크리스트)”\*\*를 드릴게요. 복붙해서 저장하고 Git에 올리면 됩니다.

---

# 📄 Supabase RLS 정책 사양서 (템플릿)

> 이 문서는 영어 학습 SaaS MVP의 **핵심 테이블 구조**와 **학습 루프**에 맞춘 RLS 정책을 정리합니다. 테이블/루프는 기획서·사양서 기준입니다. (핵심 테이블 8종 + 선택 concepts)
> 출제→제출→채점→SRS→세션완료의 런타임 루프에서 스냅샷 기준 채점이 핵심입니다.

## 0) 문서 목적

* **보안 원칙**: 사용자는 **자기 데이터만** 조회/작성, 운영 편집은 **service\_role** 전용
* **운영 편의**: 정책 변경 이력 관리(깃), 정책 의도와 SQL의 1:1 매핑
* **테스트 방법**: 쿼리 예시 포함(정책 검증)

---

## 1) 적용 범위 (테이블)

* 필수: `users`, `items`, `sessions`, `session_items`, `attempts`, `grades`, `user_item_status`, `user_concept_status`
* 선택: `concepts` (설명/검색 품질)

---

## 2) 공통 설정 (RLS ON & enum 확인)

```sql
-- RLS 활성화
alter table public.users enable row level security;
alter table public.items enable row level security;
alter table public.sessions enable row level security;
alter table public.session_items enable row level security;
alter table public.attempts enable row level security;
alter table public.grades enable row level security;
alter table public.user_item_status enable row level security;
alter table public.user_concept_status enable row level security;
alter table public.concepts enable row level security;

-- 채점 함수에서 사용하는 enum(없으면 생성)
do $$
begin
  if not exists (select 1 from pg_type where typname = 'grade_label') then
    create type grade_label as enum ('correct','variant','near_miss','wrong');
  end if;
  if not exists (select 1 from pg_type where typname = 'judge_type') then
    create type judge_type as enum ('rule','ai');
  end if;
end $$;
```

---

## 3) 테이블별 정책

### 3.1 `items` (문항 원본)

**의도:** 사용자는 승인된(`approved`) 문항만 조회. 초안/아카이브는 **운영(서버)** 전용. 출제 시점에는 `session_items.snapshot_json`으로 **동결**, 채점·복원은 **스냅샷 기준**.

```sql
-- 로그인 사용자: 승인된 문항만 읽기
create policy "items_select_approved_only"
on public.items
for select
to authenticated
using (status = 'approved');

-- 운영/관리(콘텐츠 편집/등록/승격): service_role 전용
create policy "items_admin_full_access"
on public.items
for all
to service_role
using (true)
with check (true);
```

### 3.2 `sessions` (세션 컨테이너)

**의도:** 본인 세션만 접근 가능.

```sql
create policy "sessions_rw_own"
on public.sessions
for all
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());
```

### 3.3 `session_items` (출제 스냅샷)

**의도:** 본인 세션의 스냅샷만 읽기, 삽입은 **함수/서버 전용**(사용자 직접 insert 금지). 스냅샷은 채점의 유일 기준.

```sql
-- 읽기: 내 세션의 스냅샷만
create policy "session_items_r_own_session"
on public.session_items
for select
to authenticated
using (
  exists (
    select 1 from public.sessions s
    where s.id = session_items.session_id
      and s.user_id = auth.uid()
  )
);

-- 삽입: 서버/함수에서만
create policy "session_items_ins_server_only"
on public.session_items
for insert
to service_role
with check (true);
```

### 3.4 `attempts` (제출)

**의도:** 본인 세션에만 제출 가능, 본인 세션 제출만 조회.

```sql
create policy "attempts_r_own_session"
on public.attempts
for select
to authenticated
using (
  exists (
    select 1 from public.sessions s
    where s.id = attempts.session_id
      and s.user_id = auth.uid()
  )
);

create policy "attempts_w_own_session"
on public.attempts
for insert
to authenticated
with check (
  exists (
    select 1 from public.sessions s
    where s.id = attempts.session_id
      and s.user_id = auth.uid()
  )
);
```

### 3.5 `grades` (채점)

**의도:** 본인 attempt에 대한 grade만 읽기/작성 가능. 초기 버전은 **룰 채점** 동기 저장.

```sql
create policy "grades_r_own_attempt"
on public.grades
for select
to authenticated
using (
  exists (
    select 1 from public.attempts a
    join public.sessions s on s.id = a.session_id
    where a.id = grades.attempt_id
      and s.user_id = auth.uid()
  )
);

create policy "grades_w_own_attempt"
on public.grades
for insert
to authenticated
with check (
  exists (
    select 1 from public.attempts a
    join public.sessions s on s.id = a.session_id
    where a.id = grades.attempt_id
      and s.user_id = auth.uid()
  )
);
```

> **향후** AI 비동기 후처리 시에는 service\_role insert 정책을 추가하세요.

### 3.6 `user_item_status` / `user_concept_status` (라이트너)

**의도:** 본인 데이터만 읽기/쓰기. 라이트너는 채점 결과에 따라 자동 갱신.

```sql
create policy "user_item_status_rw_own"
on public.user_item_status
for all
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());

create policy "user_concept_status_rw_own"
on public.user_concept_status
for all
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());
```

### 3.7 `concepts` (선택)

**의도:** 로그인 사용자는 읽기 가능, 편집은 운영 전용.

```sql
create policy "concepts_r_all_auth"
on public.concepts
for select
to authenticated
using (true);

create policy "concepts_admin_full"
on public.concepts
for all
to service_role
using (true)
with check (true);
```

### 3.8 `users`

**의도:** 본인 프로필만 읽기/수정.

```sql
create policy "users_rw_self"
on public.users
for all
to authenticated
using (id = auth.uid())
with check (id = auth.uid());
```

---

## 4) 함수 보안 (출제→제출→채점→SRS→완료)

**의도:** 일부 테이블 insert를 사용자에게 직접 열어두지 않고, **함수로만 수행**(SECURITY DEFINER). 사용자는 함수 실행 권한만 가짐. 루프용 함수는 사양서와 1:1 매핑.

```sql
-- SECURITY DEFINER + search_path 고정 + 실행권한
alter function public.start_session(uuid, int) security definer set search_path = public;
alter function public.submit_attempt(uuid, uuid, text, int) security definer set search_path = public;
alter function public.save_grade(uuid, grade_label, text, text, text[], judge_type, jsonb) security definer set search_path = public;
alter function public.update_srs(uuid) security definer set search_path = public;
alter function public.complete_session(uuid) security definer set search_path = public;

grant execute on function public.start_session(uuid, int) to authenticated;
grant execute on function public.submit_attempt(uuid, uuid, text, int) to authenticated;
grant execute on function public.save_grade(uuid, grade_label, text, text, text[], judge_type, jsonb) to authenticated;
grant execute on function public.update_srs(uuid) to authenticated;
grant execute on function public.complete_session(uuid) to authenticated;
```

---

## 5) 인덱스 (권장)

루프/대시보드 조회 기준에 맞춘 인덱스.

```sql
create index if not exists idx_sessions_user_status on public.sessions(user_id, status);
create index if not exists idx_session_items_session_order on public.session_items(session_id, order_index);
create index if not exists idx_attempts_session_item on public.attempts(session_id, item_id);
create index if not exists idx_grades_attempt on public.grades(attempt_id);
create index if not exists idx_user_item_status_next_due on public.user_item_status(user_id, next_due_at);
create index if not exists idx_user_concept_status_next_due on public.user_concept_status(user_id, next_due_at);
```

---

## 6) 점검(검증) 시나리오

* **세션 시작 → 스냅샷 생성**: `start_session()` 호출 후 `session_items`에 insert 되었는지 확인 (사용자는 직접 insert 권한 없음)
* **제출/채점**: 내 세션에만 제출/채점 insert 가능, 타 사용자 세션이면 거부되어야 함
* **SRS 갱신 & 조회**: 본인 user\_id에 대해서만 read/write 가능

샘플 쿼리(아이디는 테스트 값으로 치환):

```sql
select start_session(auth.uid(), 3) as new_session;
-- 내 세션 스냅샷만 보이는지
select count(*) from session_items si
join sessions s on s.id = si.session_id
where s.user_id = auth.uid();

-- 남의 세션 시도 → 0행/거부가 정상
select * from attempts a
join sessions s on s.id = a.session_id
where s.user_id <> auth.uid();
```

user_level_history 테이블에 RLS(Row Level Security)를 지정하는 방법을 단계별로 정리
일반 사용자 → 자기 레벨 이력만 읽고(insert 가능)
관리자(users.role='admin') → 모든 사용자 이력 조회/추가 가능
service_role → 전체 조작 가능

```sql
-- 🔹 user_level_history 테이블 생성
create table if not exists public.user_level_history (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  level int not null,
  source text not null,                      -- 변경 근거: onboarding | auto_assessment | manual_override
  changed_at timestamp not null default now()
);

-- 🔹 RLS 활성화
alter table public.user_level_history enable row level security;

-- 🔹 사용자 정책 (본인 이력만 조회/추가 가능)
drop policy if exists "user_level_history_r_own" on public.user_level_history;
create policy "user_level_history_r_own"
on public.user_level_history
for select
to authenticated
using (user_id = auth.uid());

drop policy if exists "user_level_history_w_own" on public.user_level_history;
create policy "user_level_history_w_own"
on public.user_level_history
for insert
to authenticated
with check (user_id = auth.uid());

-- 🔹 관리자 정책 (전체 조회/추가 가능)
drop policy if exists "user_level_history_r_admin" on public.user_level_history;
create policy "user_level_history_r_admin"
on public.user_level_history
for select
to authenticated
using (
  exists (
    select 1 from public.users u
    where u.id = auth.uid()
      and u.role = 'admin'
  )
);

drop policy if exists "user_level_history_w_admin" on public.user_level_history;
create policy "user_level_history_w_admin"
on public.user_level_history
for insert
to authenticated
with check (
  exists (
    select 1 from public.users u
    where u.id = auth.uid()
      and u.role = 'admin'
  )
);

-- 🔹 service_role 전용: 전체 권한 허용 (운영/서버 함수용)
drop policy if exists "user_level_history_admin_full" on public.user_level_history;
create policy "user_level_history_admin_full"
on public.user_level_history
for all
to service_role
using (true)
with check (true);
```

---

