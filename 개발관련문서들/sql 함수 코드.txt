create or replace function public.get_session_result(p_session_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();            -- ?꾩옱 濡쒓렇?명븳 ?ъ슜??
  _own boolean;                       -- ?몄뀡 ?뚯쑀 ?щ?
  _result jsonb;                      -- 理쒖쥌 諛섑솚 JSON
begin
  select exists (
    select 1
    from public.sessions s
    where s.id = p_session_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  with si as (
    select id, session_id, item_id, order_index, snapshot_json
    from public.session_items
    where session_id = p_session_id
  ),
  la_graded as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    join public.grades g on g.attempt_id = a.id
    where a.session_id = p_session_id
    order by a.item_id, g.created_at desc nulls last, a.submitted_at desc nulls last, a.id desc
  ),
  la_all as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    where a.session_id = p_session_id
    order by a.item_id, a.submitted_at desc nulls last, a.id desc
  ),
  la as (
    select
      coalesce(g.item_id, a.item_id) as item_id,
      coalesce(g.attempt_id, a.attempt_id) as attempt_id,
      coalesce(g.answer_raw, a.answer_raw) as answer_raw,
      coalesce(g.submitted_at, a.submitted_at) as submitted_at,
      coalesce(g.latency_ms, a.latency_ms) as latency_ms
    from la_all a
    left join la_graded g on g.item_id = a.item_id
  ),
  gr as (
    select attempt_id, label, feedback_short, minimal_rewrite, error_tags
    from public.grades
  ),
  ck as (                             -- ?몄뀡 ???깆옣??concept_key 紐⑸줉
    select distinct si.snapshot_json->>'concept_key' as concept_key
    from si
    where si.snapshot_json ? 'concept_key'
  ),
  cm as (                             -- 媛쒕뀗?믫븳湲紐?留ㅽ븨
    select c.concept_key, c.display_name, coalesce(c.description, '') as description
    from public.concepts c
    join ck on ck.concept_key = c.concept_key
  ),
  meta as (
    select s.started_at, s.ended_at
    from public.sessions s
    where s.id = p_session_id
  )
  select jsonb_build_object(
    'session_id', p_session_id,
    'started_at', to_char((select started_at from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'ended_at',   to_char((select ended_at   from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'total',      (select count(*) from si),                          -- ??count(*) 濡?援먯껜
    'correct',    coalesce((
                     select count(*)
                     from la
                     join gr on gr.attempt_id = la.attempt_id
                     where gr.label in ('correct','variant')
                   ), 0),
    'items',      coalesce((
                     select jsonb_agg(
                       jsonb_build_object(
                         'order_index',    si.order_index,
                         'item_id',        si.item_id,
                         'question',       si.snapshot_json->>'source_ko',
                         'correct_answer', si.snapshot_json->>'answer_en',
                         'concept_key',    si.snapshot_json->>'concept_key',
                         'concept_ko',     (
                                            select cm.display_name
                                            from cm
                                            where cm.concept_key = si.snapshot_json->>'concept_key'
                                            limit 1
                                          ),
                         'attempt_id',     la.attempt_id,
                         'submitted_at',   to_char(la.submitted_at, 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
                         'latency_ms',     la.latency_ms,
                         'user_answer',    la.answer_raw,
                         'label',          gr.label,
                         'feedback',       gr.feedback_short,
                         'minimal_rewrite',gr.minimal_rewrite
                       )
                       order by si.order_index
                     )
                     from si
                     left join la on la.item_id = si.item_id
                     left join gr on gr.attempt_id = la.attempt_id
                   ), '[]'::jsonb)
  )
  into _result;

  return _result;
end;
$$;

----------------------
create or replace function public.save_grade(
  p_attempt_id uuid,
  p_label grade_label,
  p_feedback text,
  p_minimal_rewrite text,
  p_error_tags text[] default array[]::text[],
  p_judge judge_type default 'rule',
  p_evidence jsonb default '{}'::jsonb
)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();
  _own boolean;
begin
  -- 0) ?뚯쑀沅?寃利? ?대떦 attempt媛 ?꾩옱 ?ъ슜???뚯쑀 ?몄뀡?몄? ?뺤씤
  select exists (
    select 1
    from public.attempts a
    join public.sessions s on s.id = a.session_id
    where a.id = p_attempt_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  -- 1) upsert: created_at? 理쒖큹 ?쎌엯留? ?낅뜲?댄듃 ?쒖뿉??蹂댁〈
  insert into public.grades (
    attempt_id,
    label,
    feedback_short,
    minimal_rewrite,
    error_tags,
    judge,
    evidence_json,
    created_at
  )
  values (
    p_attempt_id,
    p_label,
    p_feedback,
    p_minimal_rewrite,
    p_error_tags,
    p_judge,
    p_evidence,
    now()
  )
  on conflict (attempt_id) do update
  set label           = excluded.label,
      feedback_short  = excluded.feedback_short,
      minimal_rewrite = excluded.minimal_rewrite,
      error_tags      = excluded.error_tags,
      judge           = excluded.judge,
      evidence_json   = excluded.evidence_json
  ;
end;
$$;

grant execute on function public.save_grade(
  uuid, grade_label, text, text, text[], judge_type, jsonb
) to authenticated;
------------------------
create or replace function complete_session(p_session_id uuid)
returns void as $$
begin
  update public.sessions
  set status = 'completed',
      ended_at = now()
  where id = p_session_id;
end;
$$ language plpgsql;

------------------------


/*
紐⑹쟻

?몄뀡 ??梨꾩젏 寃곌낵(grade)瑜?諛뷀깢?쇰줈 ?쇱씠?몃꼫 諛뺤뒪瑜?媛깆떊
?⑥뼱/援?word/phrase) ??user_item_status
臾몄옣(sentence) ??user_concept_status
媛숈? 臾명빆???ㅼ쨷 ?쒕룄媛 ?덉쓣 寃쎌슦 "留덉?留?媛??理쒓렐) 梨꾩젏???쒕룄"留?諛섏쁺
????먯젙 洹쒖튃

session_items.snapshot_json->>'type' (?뚮Ц??
items.type::text (?뚮Ц??
concept_key ?좊Т濡?異붿젙 (?덉쑝硫?sentence, ?놁쑝硫?word)
媛꾧꺽????
box 1: 0d, 2: 1d, 3: 3d, 4: 7d, 5: 14d

?꾩젣

user_item_status(user_id, item_id) unique

user_concept_status(user_id, concept_key) unique

attempts:grades = 1:1?대ŉ, grades.label ??('correct','variant','near_miss','wrong')

蹂??⑥닔??SECURITY DEFINER?대ŉ, ?대??먯꽌 ?꾩슂???뚯씠釉붿뿉 ???RLS ?덉슜 ?먮뒗 ?고쉶瑜?蹂댁옣?댁빞 ??
*/

create or replace function public.update_srs(p_session_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  rec record;
  v_is_correct boolean;

  -- item(word/phrase)??
  v_prev_item int;
  v_next_box_item int;
  v_interval_item int;

  -- concept(sentence)??
  v_prev_concept int;
  v_next_box_concept int;
  v_interval_concept int;

  v_item_type text;
begin
  -- 媛?臾명빆(item)蹂?媛??理쒓렐 1媛?attempt(梨꾩젏 ?꾨즺??寃껊쭔)留??좊퀎
  for rec in
    with last_per_item as (
      select distinct on (a.item_id)
             a.id as attempt_id
      from public.attempts a
      join public.grades g
        on g.attempt_id = a.id
      where a.session_id = p_session_id
      order by a.item_id,
               g.created_at desc nulls last,
               a.submitted_at desc nulls last,
               a.id desc
    )
    select a.item_id,
           g.label,
           s.user_id,
           si.snapshot_json->>'concept_key' as concept_key
    from last_per_item l
    join public.attempts a on a.id = l.attempt_id
    join public.grades   g on g.attempt_id = a.id
    join public.sessions s on s.id = a.session_id
    join public.session_items si
      on si.session_id = a.session_id
     and si.item_id    = a.item_id
  loop
    v_is_correct := (rec.label in ('correct','variant'));

    -- item ???援щ텇: concept_key 議댁옱 ??sentence, ?꾨땲硫?word/phrase
    if rec.concept_key is not null then
      v_item_type := 'sentence';
    else
      v_item_type := 'word';
    end if;

    -- 1) ?⑥뼱/援?phrase/word): user_item_status ?낅뜲?댄듃
    if v_item_type in ('word','phrase') then
      select box_level into v_prev_item
      from public.user_item_status
      where user_id = rec.user_id
        and item_id = rec.item_id;

      if v_is_correct then
        v_next_box_item := least(coalesce(v_prev_item, 0) + 1, 5);
      else
        v_next_box_item := 1;
      end if;

      v_interval_item := case v_next_box_item
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_item_status(
        user_id, item_id, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.item_id, v_next_box_item, now(), now() + make_interval(days => v_interval_item),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, item_id) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_item_status.streak         + excluded.streak,
            total_attempts  = public.user_item_status.total_attempts + 1,
            correct_count   = public.user_item_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_item_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;

    -- 2) 臾몄옣(sentence): user_concept_status ?낅뜲?댄듃
    if v_item_type = 'sentence' and rec.concept_key is not null then
      select box_level into v_prev_concept
      from public.user_concept_status
      where user_id = rec.user_id
        and concept_key = rec.concept_key;

      if v_is_correct then
        v_next_box_concept := least(coalesce(v_prev_concept, 0) + 1, 5);
      else
        v_next_box_concept := 1;
      end if;

      v_interval_concept := case v_next_box_concept
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_concept_status(
        user_id, concept_key, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.concept_key, v_next_box_concept, now(), now() + make_interval(days => v_interval_concept),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, concept_key) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_concept_status.streak         + excluded.streak,
            total_attempts  = public.user_concept_status.total_attempts + 1,
            correct_count   = public.user_concept_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_concept_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;
  end loop;

  return;
end;
$$;


---------------------------
create or replace function submit_attempt(
  p_session_id uuid,
  p_item_id uuid,
  p_answer_raw text,
  p_latency_ms int
)
returns uuid as $$
declare
  v_attempt_id uuid;
begin
  insert into public.attempts(session_id, item_id, answer_raw, latency_ms)
  values (p_session_id, p_item_id, p_answer_raw, p_latency_ms)
  returning id into v_attempt_id;

  return v_attempt_id;
end;
$$ language plpgsql;

-----------------------------
-- ?뚯씪/??븷: DB ?⑥닔 / 異쒖젣+?몄뀡?앹꽦+?ㅻ깄???숆껐
-- ?섏〈: policy_level_mix, policy_type_weights, policy_thresholds, users, items,
--       attempts, user_item_status, user_concept_status, sessions, session_items
-- 二쇱쓽: SECURITY DEFINER + search_path 怨좎젙

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,
  p_count int default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;
  v_level_mix jsonb;
  v_type_weights jsonb;

  v_level_attempts int;
  v_effective_type session_type;

  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;
begin
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  select coalesce(u.current_level, 1)
    into v_current_level
  from users u
  where u.id = p_user_id;

  select plm.level_weights
    into v_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_level_mix is null then
    v_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  select ptw.weights
    into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review', 0.5, 'new', 0.3, 'weak', 0.2);
  end if;

  select coalesce(count(*), 0)
    into v_level_attempts
  from user_item_history uih
  join items i on i.id = uih.item_id
  where uih.user_id = p_user_id
    and coalesce(i.level, 0) = v_current_level;

  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor((v_type_weights->>'review')::numeric * v_count)::int;
    tgt_new    := floor((v_type_weights->>'new')::numeric    * v_count)::int;
    tgt_weak   := floor((v_type_weights->>'weak')::numeric   * v_count)::int;
    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1;
      end if;
    end loop;
  end if;

  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_level_mix)
    order by 1
  ),
  ls_base as (
    select
      lvl.lvl as level,
      floor(lvl.w * tgt_new)::int    as new_limit_base,
      floor(lvl.w * tgt_review)::int as review_limit_base,
      floor(lvl.w * tgt_weak)::int   as weak_limit_base,
      (lvl.w * tgt_new)    - floor(lvl.w * tgt_new)    as new_frac,
      (lvl.w * tgt_review) - floor(lvl.w * tgt_review) as review_frac,
      (lvl.w * tgt_weak)   - floor(lvl.w * tgt_weak)   as weak_frac
    from lvl
  ),
  ls_sums as (
    select
      sum(new_limit_base)    as sum_new_base,
      sum(review_limit_base) as sum_review_base,
      sum(weak_limit_base)   as sum_weak_base
    from ls_base
  ),
  ls_ranked as (
    select
      b.*,
      row_number() over (order by b.new_frac desc,    b.level) as rn_new,
      row_number() over (order by b.review_frac desc, b.level) as rn_review,
      row_number() over (order by b.weak_frac desc,   b.level) as rn_weak
    from ls_base b
  ),
  level_slots as (
    select
      r.level,
      r.new_limit_base    + case when r.rn_new    <= greatest(tgt_new    - ls.sum_new_base,    0) then 1 else 0 end as new_limit,
      r.review_limit_base + case when r.rn_review <= greatest(tgt_review - ls.sum_review_base, 0) then 1 else 0 end as review_limit,
      r.weak_limit_base   + case when r.rn_weak   <= greatest(tgt_weak   - ls.sum_weak_base,   0) then 1 else 0 end as weak_limit
    from ls_ranked r
    cross join ls_sums ls
  ),
  user_seen as (
    select item_id from user_item_history where user_id = p_user_id
    union
    select distinct a.item_id
    from attempts a
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft', 'approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count, 0) + coalesce(ucs.wrong_count, 0) as wscore,
           greatest(coalesce(uis.wrong_count, 0), coalesce(ucs.wrong_count, 0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft', 'approved')
      and (coalesce(uis.total_attempts, 0) + coalesce(ucs.total_attempts, 0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft', 'approved')
      and us.item_id is null
  ),
  pick_review as (
    select id
    from (
      select
        ri.id,
        row_number() over (partition by ri.level order by ri.is_due desc, ri.due_at asc, ri.created_at desc) as rn,
        coalesce(ls.review_limit, 0) as limit_per_level
      from review_items ri
      join level_slots ls on ls.level = ri.level
    ) ranked
    where rn <= limit_per_level
  ),
  pick_weak as (
    select id
    from (
      select
        wi.id,
        row_number() over (partition by wi.level order by wi.wscore desc, wi.maxw desc) as rn,
        coalesce(ls.weak_limit, 0) as limit_per_level
      from weak_items wi
      join level_slots ls on ls.level = wi.level
    ) ranked
    where rn <= limit_per_level
  ),
  pick_new as (
    select id
    from (
      select
        ni.id,
        row_number() over (partition by ni.level order by ni.created_at desc) as rn,
        coalesce(ls.new_limit, 0) as limit_per_level
      from new_items ni
      join level_slots ls on ls.level = ni.level
    ) ranked
    where rn <= limit_per_level
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  picked_counts as (
    select i.level, count(*) as picked_count
    from items i
    join picked_dedup pd on pd.id = i.id
    group by i.level
  ),
  remaining_slots as (
    select
      ls.level,
      greatest(
        coalesce(ls.new_limit, 0)
        + coalesce(ls.review_limit, 0)
        + coalesce(ls.weak_limit, 0)
        - coalesce(pc.picked_count, 0),
        0
      ) as remaining_total
    from level_slots ls
    left join picked_counts pc on pc.level = ls.level
  ),
  fillup_primary as (
    select id
    from (
      select
        i.id,
        rs.level,
        row_number() over (partition by i.level order by i.created_at desc) as rn,
        rs.remaining_total,
        us2.item_id as seen_item
      from items i
      join remaining_slots rs on rs.level = i.level
      left join picked_dedup pd on pd.id = i.id
      left join user_seen us2 on us2.item_id = i.id
      where pd.id is null
        and rs.remaining_total > 0
        and i.status in ('draft', 'approved')
        and (
          (v_effective_type = 'new_only' and us2.item_id is null)
          or (v_effective_type <> 'new_only')
        )
    ) ranked
    where rn <= remaining_total
  ),
  fillup_fallback as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    left join fillup_primary fp on fp.id = i.id
    left join user_seen us2 on us2.item_id = i.id
    where pd.id is null
      and fp.id is null
      and i.status in ('draft', 'approved')
      and (
        (v_effective_type = 'new_only' and us2.item_id is null)
        or (v_effective_type <> 'new_only')
      )
    order by i.created_at desc
    limit greatest(
      v_count
      - (select count(*) from picked_dedup)
      - (select count(*) from fillup_primary),
      0
    )
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup_primary
    union all
    select id from fillup_fallback
    limit v_count
  ) f;

  insert into public.sessions(user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review', tgt_review, 'weak', tgt_weak, 'new', tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled',      (select count(*) from tmp_final_ids),
      'level_mix',   v_level_mix
    )
  )
  returning id into v_session_id;

  insert into public.session_items(session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;
----------------------------------
create or replace function public.get_concepts_ko(p_keys text[])
returns table (concept_key text, display_name text, description text)
language sql
security definer
set search_path = public
as $$
with src as (
select concept_key, display_name, coalesce(description, '') as description
from public.concepts
where concept_key = any(p_keys)
)
select concept_key, display_name, description from src;
$$;

grant execute on function public.get_concepts_ko(text[]) to authenticated;
-------------------------
-- 寃쎈줈: supabase/migrations/20250916_level_functions.sql
-- ??븷: ?덈꺼 ?듦퀎쨌?먯젙쨌?몄뀡 ?앹꽦 ?⑥닔 ?뺤쓽
-- ?섏〈愿怨? users, sessions, attempts, grades, user_concept_status, items, policy_level_* ?뚯씠釉? policy_thresholds, policy_type_weights
-- ?ы븿 ?⑥닔: normalize_level_mix, get_user_level_stats, get_difficulty_adjustment, evaluate_user_level_progress, auto_level_up, start_session_custom

set check_function_bodies = on;

create or replace function normalize_level_mix(p_mix jsonb)
returns jsonb
language plpgsql
immutable
as $$
declare
  v_total numeric := 0;
  v_result jsonb := '{}'::jsonb;
  v_key text;
  v_val numeric;
begin
  if p_mix is null then
    return '{}'::jsonb;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_total := v_total + v_val;
    end if;
  end loop;

  if v_total <= 0 then
    return p_mix;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_result := v_result || jsonb_build_object(v_key, round((v_val / v_total)::numeric, 4));
    end if;
  end loop;

  return v_result;
end;
$$;
-- normalize_level_mix: ?덈꺼 遺꾪룷 JSON ?⑷퀎 1.0 ?뺢퇋??

create or replace function get_user_level_stats(p_user_id uuid)
returns table (
  recent_session_id uuid,
  recent_session_started_at timestamptz,
  recent_session_ended_at timestamptz,
  recent_attempts int,
  recent_correct_attempts int,
  recent_correct_rate numeric,
  total_attempts bigint,
  stable_concept_count bigint,
  stable_concept_ratio numeric,
  low_box_concept_count bigint
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_total_concepts bigint;
  v_progress record;
begin
  select sb.id, sb.started_at, sb.ended_at
    into recent_session_id, recent_session_started_at, recent_session_ended_at
  from public.session_bundles sb
  where sb.user_id = p_user_id
  order by sb.bundle_seq desc
  limit 1;

  select total_items, correct_items
    into recent_attempts, recent_correct_attempts
  from public.user_recent_bundle_stats
  where user_id = p_user_id
  order by ended_at desc
  limit 1;

  recent_attempts := coalesce(recent_attempts, 0);
  recent_correct_attempts := coalesce(recent_correct_attempts, 0);
  if recent_attempts > 0 then
    recent_correct_rate := round((recent_correct_attempts::numeric / recent_attempts)::numeric, 4);
  else
    recent_correct_rate := 0;
  end if;

  select total_attempts, total_correct
    into v_progress
  from public.user_progress_stats
  where user_id = p_user_id;

  if found then
    total_attempts := coalesce(v_progress.total_attempts, 0);
  else
    total_attempts := 0;
  end if;

  if total_attempts = 0 then
    select coalesce(sum(ucs.total_attempts), 0)
      into total_attempts
    from public.user_concept_status ucs
    where ucs.user_id = p_user_id;
  end if;

  select coalesce(count(*), 0)
    into stable_concept_count
  from public.user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level >= 4;

  select coalesce(count(*), 0)
    into v_total_concepts
  from public.user_concept_status ucs
  where ucs.user_id = p_user_id;

  stable_concept_ratio :=
    case when v_total_concepts > 0
         then round((stable_concept_count::numeric / v_total_concepts)::numeric, 4)
         else 0 end;

  select coalesce(count(*), 0)
    into low_box_concept_count
  from public.user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level <= 2;

  return next;
end;
$$;

create or replace function get_difficulty_adjustment(p_user_id uuid)
returns table (
  applied boolean,
  reason text,
  policy_level int,
  recent_correct_rate numeric,
  low_box_concept_count bigint,
  adjusted_mix jsonb
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_level int;
  v_condition jsonb;
  v_threshold_rate numeric;
  v_threshold_low int;
begin
  select current_level
  into v_level
  from users
  where id = p_user_id;

  if v_level is null then
    applied := false;
    reason := '?ъ슜???덈꺼 ?뺣낫 ?놁쓬';
    policy_level := null;
    recent_correct_rate := 0;
    low_box_concept_count := 0;
    adjusted_mix := null;
    return next;
  end if;

  policy_level := v_level;

  -- 理쒓렐 ?뺣떟瑜?
  with recent_sessions as (
    select s.id
    from sessions s
    where s.user_id = p_user_id
      and s.status = 'completed'
    order by coalesce(s.ended_at, s.started_at) desc
    limit 3
  ),
  recent_attempts as (
    select a.id
    from attempts a
    where a.session_id in (select id from recent_sessions)
  ),
  recent_labels as (
    select g.label
    from grades g
    join recent_attempts a on a.id = g.attempt_id
  )
  select case
           when count(*) > 0 then round((count(*) filter (where label in ('correct','variant'))::numeric / count(*))::numeric, 4)
           else 0
         end
  into recent_correct_rate
  from recent_labels;

  -- ??? 諛뺤뒪 媛쒖닔
  select coalesce(gs.low_box_concept_count, 0)
  into low_box_concept_count
  from get_user_level_stats(p_user_id) as gs;

  select condition_json, adjusted_mix_json
  into v_condition, adjusted_mix
  from policy_level_adjustments
  where level = v_level;

  if v_condition is null or adjusted_mix is null then
    applied := false;
    reason := '議곗젙 ?뺤콉 ?놁쓬';
    adjusted_mix := null;
    return next;
  end if;

  v_threshold_rate := coalesce((v_condition->>'recent_correct_rate_below')::numeric, 0.6);
  v_threshold_low := coalesce((v_condition->>'low_box_concepts_over')::int, 5);

  if recent_correct_rate < v_threshold_rate
     and low_box_concept_count >= v_threshold_low then
    applied := true;
    reason := format('理쒓렐 ?뺣떟瑜?%.2f < ?뺤콉 %.2f, ??? 諛뺤뒪 %s ??%s',
                     recent_correct_rate, v_threshold_rate,
                     low_box_concept_count, v_threshold_low);
    adjusted_mix := normalize_level_mix(adjusted_mix);
  else
    applied := false;
    reason := '議곌굔 誘몄땐議?;
    adjusted_mix := null;
  end if;

  return next;
end;
$$;


-- get_difficulty_adjustment: 理쒓렐 ?깃낵 湲곕컲 ?쒖씠??議곗젙 ?먯젙

create or replace function evaluate_user_level_progress(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_current int;
  v_target int;
  v_policy policy_level_up%rowtype;
  v_stats record;
  v_pass boolean := false;
  v_reason text := '';
begin
  select current_level
  into v_current
  from users
  where id = p_user_id;

  if v_current is null then
    return jsonb_build_object(
      'eligible', false,
      'reason', '?덈꺼 ?뺣낫 ?놁쓬'
    );
  end if;

  v_target := v_current + 1;

  select * into v_policy
  from policy_level_up
  where level = v_target;

  if not found then
    return jsonb_build_object(
      'eligible', false,
      'reason', '?ㅼ쓬 ?덈꺼 ?뺤콉 誘몄젙??,
      'current_level', v_current,
      'target_level', v_target
    );
  end if;

  select * into v_stats
  from get_user_level_stats(p_user_id);

  if coalesce(v_stats.total_attempts, 0) < v_policy.min_total_attempts then
    v_reason := format('?꾩쟻 ?쒕룄??%s < %s',
                       coalesce(v_stats.total_attempts, 0),
                       v_policy.min_total_attempts);
  elsif coalesce(v_stats.recent_correct_rate, 0) < v_policy.min_correct_rate then
    v_reason := format('理쒓렐 ?뺣떟瑜?%.2f < %.2f',
                       coalesce(v_stats.recent_correct_rate, 0),
                       v_policy.min_correct_rate);
  elsif coalesce(v_stats.stable_concept_ratio, 0) < v_policy.min_box_level_ratio then
    v_reason := format('?덉젙 鍮꾩쑉 %.2f < %.2f',
                       coalesce(v_stats.stable_concept_ratio, 0),
                       v_policy.min_box_level_ratio);
  else
    v_pass := true;
    v_reason := '?뺤콉 異⑹”';
  end if;

  return jsonb_build_object(
    'eligible', v_pass,
    'reason', v_reason,
    'current_level', v_current,
    'target_level', v_target,
    'stats', to_jsonb(v_stats)
  );
end;
$$;
-- evaluate_user_level_progress: ?밴툒 媛???щ? ?먯젙

create or replace function auto_level_up(p_user_id uuid, p_source text default 'auto_assessment')
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_eval jsonb;
  v_eligible boolean;
  v_target int;
  v_new_level int;
begin
  v_eval := evaluate_user_level_progress(p_user_id);
  v_eligible := coalesce((v_eval->>'eligible')::boolean, false);
  v_target := (v_eval->>'target_level')::int;

  if not v_eligible then
    return jsonb_build_object(
      'leveled_up', false,
      'reason', v_eval->>'reason',
      'current_level', v_eval->>'current_level'
    );
  end if;

  update users
  set current_level = v_target
  where id = p_user_id
  returning current_level
  into v_new_level;

  insert into user_level_history (user_id, level, source)
  values (p_user_id, v_new_level, coalesce(p_source, 'auto_assessment'));

  return jsonb_build_object(
    'leveled_up', true,
    'new_level', v_new_level,
    'source', coalesce(p_source, 'auto_assessment')
  );
end;
$$;
-- auto_level_up: ?밴툒 泥섎━ 諛??대젰 湲곕줉
------------------------------------
create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,
  p_count int default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;
  v_base_level_mix jsonb;
  v_applied_level_mix jsonb;
  v_type_weights jsonb;

  v_level_attempts int;
  v_effective_type session_type;

  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

  v_adjust record;
  v_stats record;

  v_remaining int;
  v_level_arr int[];
  v_arr_len int;
  i int;
  v_result_level_mix jsonb := '{}'::jsonb;
begin
  -- 0) ?뺤콉 ?꾧퀎媛?濡쒕뱶
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) ?꾩옱 ?덈꺼怨?湲곕낯 ?덈꺼 誘뱀뒪 濡쒕뱶
  select coalesce(u.current_level, 1)
  into v_current_level
  from users u
  where u.id = p_user_id;

  select plm.level_weights
  into v_base_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_base_level_mix is null then
    v_base_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- ?쒖씠??蹂댁젙 ?곸슜
  select * into v_adjust
  from get_difficulty_adjustment(p_user_id);

  if v_adjust.applied and v_adjust.adjusted_mix is not null then
    v_applied_level_mix := v_adjust.adjusted_mix;
  else
    v_applied_level_mix := v_base_level_mix;
  end if;

  v_applied_level_mix := normalize_level_mix(v_applied_level_mix);

  -- 2) ???蹂듭뒿/?좉퇋/痍⑥빟) 鍮꾩쨷 濡쒕뱶
  select ptw.weights
  into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) ?꾩옱 ?덈꺼 ?숈뒿 ?대젰 泥댄겕 ??媛뺤젣 ?좉퇋 ?щ? ?먮떒
  select coalesce(count(*),0)
  into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 4) ??낅퀎 紐⑺몴 媛쒖닔 ?곗젙
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor((coalesce(v_type_weights->>'review','0'))::numeric * v_count)::int;
    tgt_new    := floor((coalesce(v_type_weights->>'new','0'))::numeric    * v_count)::int;
    tgt_weak   := floor((coalesce(v_type_weights->>'weak','0'))::numeric   * v_count)::int;

    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1;
      end if;
    end loop;
  end if;

  -- 5) ?덈꺼 誘뱀뒪???곕Ⅸ 紐⑺몴 ?섎웾 怨꾩궛 (珥앺빀)
  drop table if exists tmp_level_targets;
  create temporary table tmp_level_targets (
    level int primary key,
    weight numeric,
    total_target int default 0
  ) on commit drop;

  insert into tmp_level_targets(level, weight, total_target)
  select lvl, weight, floor(weight * v_count)::int
  from (
    select (key)::int as lvl, (value)::numeric as weight
    from jsonb_each(v_applied_level_mix)
  ) s
  order by weight desc, lvl;

  select array_agg(level order by weight desc, level asc)
  into v_level_arr
  from tmp_level_targets;

  v_arr_len := coalesce(array_length(v_level_arr, 1), 0);

  select v_count - coalesce(sum(total_target), 0)
  into v_remaining
  from tmp_level_targets;

  if v_remaining > 0 and v_arr_len > 0 then
    for i in 0..(v_remaining - 1) loop
      update tmp_level_targets
      set total_target = total_target + 1
      where level = v_level_arr[(i % v_arr_len) + 1];
    end loop;
  end if;

  -- 6) ??낅퀎 紐⑺몴瑜??덈꺼蹂꾨줈 遺꾨같
  drop table if exists tmp_target_review;
  drop table if exists tmp_target_new;
  drop table if exists tmp_target_weak;

  create temporary table tmp_target_review(
    level int primary key,
    target int default 0
  ) on commit drop;

  create temporary table tmp_target_new(
    level int primary key,
    target int default 0
  ) on commit drop;

  create temporary table tmp_target_weak(
    level int primary key,
    target int default 0
  ) on commit drop;

  insert into tmp_target_review(level, target)
  select level,
         case when tgt_review > 0 then floor(weight * tgt_review)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  insert into tmp_target_new(level, target)
  select level,
         case when tgt_new > 0 then floor(weight * tgt_new)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  insert into tmp_target_weak(level, target)
  select level,
         case when tgt_weak > 0 then floor(weight * tgt_weak)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  if tgt_review > 0 and v_arr_len > 0 then
    select tgt_review - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_review;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_review
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  if tgt_new > 0 and v_arr_len > 0 then
    select tgt_new - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_new;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_new
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  if tgt_weak > 0 and v_arr_len > 0 then
    select tgt_weak - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_weak;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_weak
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  -- 7) ?꾨낫 ?꾩씠???좊컻
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select result.id, tr.level
    from tmp_target_review tr
    cross join lateral (
      select ri.id
      from review_items ri
      where ri.level = tr.level
      order by (case when v_review_due_first then ri.is_due else 0 end) desc,
               (case when v_review_due_first then ri.due_at else ri.created_at end) asc
      limit tr.target
    ) result
  ),
  pick_weak as (
    select result.id, tw.level
    from tmp_target_weak tw
    cross join lateral (
      select wi.id
      from weak_items wi
      where wi.level = tw.level
        and ((not v_weak_requires_history) or wi.maxw > 0)
      order by wi.wscore desc, wi.maxw desc
      limit tw.target
    ) result
  ),
  pick_new as (
    select result.id, tn.level
    from tmp_target_new tn
    cross join lateral (
      select ni.id
      from new_items ni
      where ni.level = tn.level
      order by ni.created_at desc
      limit tn.target
    ) result
  ),
  picked as (
    select id, level from pick_review
    union all
    select id, level from pick_weak
    union all
    select id, level from pick_new
  ),
  picked_ranked as (
    select id, level,
           row_number() over (partition by id order by level) as rn
    from picked
  ),
  picked_dedup as (
    select id, level
    from picked_ranked
    where rn = 1
  ),
  current_level_counts as (
    select level, count(*) as picked
    from picked_dedup
    group by level
  ),
  level_slots as (
    select t.level,
           t.total_target,
           t.weight,
           coalesce(c.picked, 0) as picked
    from tmp_level_targets t
    left join current_level_counts c on c.level = t.level
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    left join level_slots ls on ls.level = i.level
    where pd.id is null
      and i.status in ('draft','approved')
    order by coalesce(ls.total_target - ls.picked, 0) desc,
             coalesce(ls.weight, 0) desc,
             i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  ),
  final_ids as (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  )
  select id from final_ids;

  -- 8) ?ъ슜???듦퀎 ?ㅻ깄??
  select * into v_stats
  from get_user_level_stats(p_user_id);

  -- ?ㅼ젣 異쒖젣???덈꺼 鍮꾩쨷 怨꾩궛
  if v_count > 0 then
    select coalesce(
      jsonb_object_agg(level::text, cnt::numeric / v_count),
      '{}'::jsonb
    )
    into v_result_level_mix
    from (
      select i.level, count(*) as cnt
      from items i
      join tmp_final_ids t on t.id = i.id
      group by i.level
    ) sub;
  else
    v_result_level_mix := '{}'::jsonb;
  end if;

  -- 9) ?몄뀡 ?앹꽦 諛??꾨왂 湲곕줉
  insert into public.sessions (user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled', (select count(*) from tmp_final_ids),
      'base_level_mix', v_base_level_mix,
      'applied_level_mix', v_applied_level_mix,
      'selected_level_mix', v_result_level_mix,
      'adjustment', jsonb_build_object(
        'applied', coalesce(v_adjust.applied, false),
        'reason', coalesce(v_adjust.reason, ''),
        'policy_level', v_adjust.policy_level,
        'recent_correct_rate', v_adjust.recent_correct_rate,
        'low_box_concept_count', v_adjust.low_box_concept_count
      ),
      'stats_snapshot', to_jsonb(v_stats)
    )
  )
  returning id into v_session_id;

  -- 10) ?몄뀡 ?꾩씠???ㅻ깄?????
  insert into public.session_items (session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;

-----------------------
-- 0) 以鍮? UUID ?앹꽦??
create extension if not exists pgcrypto;

-- 1) 怨듯넻 updated_at ?몃━嫄?(以묐났 ?앹꽦 諛⑹?)
create or replace function public.touch_updated_at()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

-- 2) products: ?먮ℓ ?곹뭹 ?뺤쓽
create table if not exists public.products (
  id text primary key,
  display_name text not null,
  list_price_krw integer not null check (list_price_krw >= 0),
  launch_price_krw integer not null check (launch_price_krw >= 0),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger trg_products_updated_at
before update on public.products
for each row execute function public.touch_updated_at();

-- 3) payments: 寃곗젣 ?붿껌/?묐떟 ?④굔
create table if not exists public.payments (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  provider text not null default 'payapp',
  provider_tx_id text unique,
  amount_krw integer not null check (amount_krw > 0),
  status text not null check (status in ('pending','paid','failed','canceled','refunded')),
  requested_at timestamptz not null default now(),
  paid_at timestamptz,
  canceled_at timestamptz,
  meta_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_payments_user_id on public.payments(user_id);
create index idx_payments_product_id on public.payments(product_id);
create index idx_payments_status on public.payments(status);

create trigger trg_payments_updated_at
before update on public.payments
for each row execute function public.touch_updated_at();

-- 4) payment_events: ?뱁썒 諛??곹깭 蹂寃?濡쒓렇
create table if not exists public.payment_events (
  id uuid primary key default gen_random_uuid(),
  payment_id uuid not null references public.payments(id) on delete cascade,
  event_type text not null,
  payload_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index idx_payment_events_payment_id on public.payment_events(payment_id);
create index idx_payment_events_event_type on public.payment_events(event_type);

-- 5) entitlements: ?댁슜沅?沅뚮━) ?뚯씠釉?
create table if not exists public.entitlements (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  payment_id uuid not null references public.payments(id) on delete cascade,
  start_at timestamptz not null,
  end_at timestamptz not null,
  is_active boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(payment_id)
);

create index idx_entitlements_user_id on public.entitlements(user_id);
create index idx_entitlements_active on public.entitlements(is_active);
create index idx_entitlements_end_at on public.entitlements(end_at);

-- is_active 媛깆떊 + users.pro_until 罹먯떆 諛섏쁺???⑥닔/?몃━嫄?
create or replace function public.entitlements_after_change()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_latest_until timestamptz;
begin
  -- is_active: start_at <= now() < end_at 議곌굔???곕씪 媛깆떊
  if (TG_OP = 'INSERT' or TG_OP = 'UPDATE') then
    if new.start_at <= now() and new.end_at > now() then
      new.is_active := true;
    else
      new.is_active := false;
    end if;
  end if;

  -- ?ъ슜??pro_until 罹먯떆 ?낅뜲?댄듃(?좏깮 ?꾨뱶媛 議댁옱???뚮쭔)
  begin
    select max(end_at) into v_latest_until
    from public.entitlements
    where user_id = new.user_id;

    update public.users
    set pro_until = v_latest_until
    where id = new.user_id;
  exception when undefined_column then
    -- users.pro_until 而щ읆???놁쑝硫?臾댁떆
    null;
  end;

  return new;
end;
$$;

create trigger trg_entitlements_upsert
before insert or update on public.entitlements
for each row execute function public.entitlements_after_change();

create trigger trg_entitlements_updated_at
before update on public.entitlements
for each row execute function public.touch_updated_at();

-- 5-1) users ?뚯씠釉붿뿉 pro_until 罹먯떆 而щ읆 異붽? (?좏깮)
alter table public.users
  add column if not exists pro_until timestamptz;

-- 6) ?몄뀡 ?쒖옉 媛???⑥닔 (臾대즺 1??+ ?댁슜沅?泥댄겕)
create or replace function public.can_start_session(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_today date := (timezone('Asia/Seoul', now()))::date;
  v_completed_today integer;
  v_pro_until timestamptz;
  v_has_entitlement boolean;
  v_can_start boolean := false;
  v_reason text := 'NO_FREE_LEFT';
begin
  -- ?ㅻ뒛 ?꾨즺???몄뀡 ??
  select count(*) into v_completed_today
  from public.sessions
  where user_id = p_user_id
    and status = 'completed'
    and (timezone('Asia/Seoul', ended_at))::date = v_today;

  -- ?쒖꽦 ?댁슜沅??щ?
  select exists (
    select 1
    from public.entitlements
    where user_id = p_user_id
      and end_at > now()
      and start_at <= now()
  ) into v_has_entitlement;

  -- pro_until 罹먯떆 (?놁쑝硫?null)
  begin
    select pro_until into v_pro_until
    from public.users where id = p_user_id;
  exception when undefined_column then
    v_pro_until := null;
  end;

  if v_has_entitlement or (v_pro_until is not null and v_pro_until > now()) then
    v_can_start := true;
    v_reason := 'OK_WITH_PRO';
  elsif v_completed_today < 1 then
    v_can_start := true;
    v_reason := 'OK_WITH_FREE';
  end if;

  return jsonb_build_object(
    'can_start', v_can_start,
    'reason', v_reason,
    'free_sessions_used_today', v_completed_today,
    'pro_until', v_pro_until
  );
end;
$$;

-- 7) RLS ?뺤콉 ?ㅼ젙
alter table public.products enable row level security;
alter table public.payments enable row level security;
alter table public.payment_events enable row level security;
alter table public.entitlements enable row level security;

-- products: ?꾧뎄??active ?곹뭹留?議고쉶 媛???좏깮?곸쑝濡?怨듦컻)
drop policy if exists products_select_active on public.products;
create policy products_select_active
on public.products
for select
using (is_active = true);

-- payments: 蹂몄씤? ?먯떊??寃곗젣留?議고쉶
drop policy if exists payments_select_own on public.payments;
create policy payments_select_own
on public.payments
for select
using (auth.uid() = user_id);

-- payment_events: 蹂몄씤 寃곗젣 濡쒓렇留?議고쉶
drop policy if exists payment_events_select_own on public.payment_events;
create policy payment_events_select_own
on public.payment_events
for select
using (
  auth.uid() = (
    select user_id from public.payments where id = payment_id
  )
);

-- entitlements: 蹂몄씤 沅뚮━留?議고쉶
drop policy if exists entitlements_select_own on public.entitlements;
create policy entitlements_select_own
on public.entitlements
for select
using (auth.uid() = user_id);

-- ?쒕퉬??濡??꾩슜 ?꾩껜 沅뚰븳 (INSERT/UPDATE/DELETE)
drop policy if exists payments_service_all on public.payments;
create policy payments_service_all
on public.payments
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists payment_events_service_all on public.payment_events;
create policy payment_events_service_all
on public.payment_events
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists entitlements_service_all on public.entitlements;
create policy entitlements_service_all
on public.entitlements
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- (?꾩슂 ?? products ?섏젙???쒕퉬??濡ㅻ쭔 ?덉슜
drop policy if exists products_service_all on public.products;
create policy products_service_all
on public.products
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');
--------------------
-- 경로: supabase/session-bundles.sql
-- 역할: 학습 세션 번들 테이블과 함수/RLS 정의
-- 의존관계: public.users, public.sessions, public.session_items, public.attempts, public.grades, public.items, public.concepts
-- 포함 함수: truncate_old_bundles(), archive_session_into_bundle(), get_bundle_result()

begin;

create table if not exists public.session_bundles (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  bundle_seq bigint not null,
  started_at timestamptz not null,
  ended_at timestamptz not null,
  session_ids jsonb not null default '[]'::jsonb,
  summary_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create unique index if not exists session_bundles_user_seq_idx
  on public.session_bundles(user_id, bundle_seq desc);

alter table public.sessions
  add column if not exists bundle_id uuid;

alter table public.sessions
  add constraint sessions_bundle_id_fkey
    foreign key (bundle_id) references public.session_bundles(id) on delete set null;

create index if not exists sessions_bundle_id_idx
  on public.sessions(bundle_id);

create or replace function public.truncate_old_bundles(
  p_user_id uuid,
  p_keep int default 30
) returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  delete from public.session_bundles sb
  using (
    select id
    from public.session_bundles
    where user_id = p_user_id
    order by bundle_seq desc
    offset greatest(coalesce(p_keep, 30), 0)
  ) old
  where sb.id = old.id;
end;
$$;

-- 진행도 요약 테이블
create table if not exists public.user_progress_stats (
  user_id uuid primary key references public.users(id) on delete cascade,
  total_attempts bigint not null default 0,
  total_correct bigint not null default 0,
  updated_at timestamptz not null default now()
);

create table if not exists public.user_recent_bundle_stats (
  user_id uuid not null references public.users(id) on delete cascade,
  bundle_id uuid not null references public.session_bundles(id) on delete cascade,
  ended_at timestamptz not null,
  total_items int not null,
  correct_items int not null,
  primary key (user_id, bundle_id)
);

create index if not exists ux_user_recent_bundle_stats_user_ended
  on public.user_recent_bundle_stats(user_id, ended_at desc);

alter table public.user_progress_stats enable row level security;
alter table public.user_recent_bundle_stats enable row level security;

drop policy if exists user_progress_stats_select_own on public.user_progress_stats;
create policy user_progress_stats_select_own
  on public.user_progress_stats
  for select
  using (user_id = auth.uid());

drop policy if exists user_progress_stats_service_all on public.user_progress_stats;
create policy user_progress_stats_service_all
  on public.user_progress_stats
  for all
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

drop policy if exists user_recent_bundle_stats_select_own on public.user_recent_bundle_stats;
create policy user_recent_bundle_stats_select_own
  on public.user_recent_bundle_stats
  for select
  using (user_id = auth.uid());

drop policy if exists user_recent_bundle_stats_service_all on public.user_recent_bundle_stats;
create policy user_recent_bundle_stats_service_all
  on public.user_recent_bundle_stats
  for all
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

create or replace function public.archive_session_into_bundle(
  p_session_id uuid
) returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session record;
  v_bundle_id uuid;
  v_next_seq bigint := 1;
  v_started timestamptz;
  v_ended timestamptz;
  v_items jsonb := '[]'::jsonb;
  v_attempts jsonb := '[]'::jsonb;
  v_calendar jsonb := '[]'::jsonb;
  v_total integer := 0;
  v_correct integer := 0;
  v_sentence integer := 0;
  v_word integer := 0;
  v_phrase integer := 0;
  v_duration_ms bigint := 0;
begin
  select s.id,
         s.user_id,
         s.started_at,
         coalesce(s.ended_at, now()) as ended_at,
         s.status,
         s.strategy_json,
         s.target_item_count
    into v_session
  from public.sessions s
  where s.id = p_session_id
  for update;

  if not found then
    raise exception 'SESSION_NOT_FOUND';
  end if;

  if v_session.user_id is null then
    raise exception 'SESSION_USER_NOT_FOUND';
  end if;

  if v_session.status is distinct from 'completed' then
    update public.sessions
      set status = 'completed',
          ended_at = coalesce(ended_at, now())
    where id = p_session_id;
  end if;

  v_started := coalesce(v_session.started_at, now());
  v_ended := coalesce(v_session.ended_at, now());
  v_duration_ms := greatest(0, (extract(epoch from (v_ended - v_started)) * 1000)::bigint);

  select coalesce(max(bundle_seq), 0) + 1
    into v_next_seq
  from public.session_bundles
  where user_id = v_session.user_id;

  with item_data as (
    select
      si.item_id,
      si.order_index,
      lower(nullif(coalesce(si.snapshot_json->>'type', it.type::text), '')) as item_type,
      coalesce(nullif(si.snapshot_json->>'level', ''), it.level::text) as item_level,
      coalesce(nullif(si.snapshot_json->>'concept_key', ''), it.concept_key) as concept_key,
      coalesce(nullif(si.snapshot_json->>'concept_ko', ''), c.display_name) as concept_ko,
      si.snapshot_json
    from public.session_items si
    left join public.items it on it.id = si.item_id
    left join public.concepts c on c.concept_key = coalesce(nullif(si.snapshot_json->>'concept_key', ''), it.concept_key)
    where si.session_id = p_session_id
  ), item_agg as (
    select
      coalesce(jsonb_agg(jsonb_build_object(
        'item_id', item_id,
        'order_index', order_index,
        'type', item_type,
        'level', item_level,
        'concept_key', concept_key,
        'concept_ko', concept_ko,
        'snapshot', snapshot_json
      ) order by order_index), '[]'::jsonb) as items_json,
      count(*) as total,
      count(*) filter (where item_type = 'sentence') as sentence_cnt,
      count(*) filter (where item_type = 'word') as word_cnt,
      count(*) filter (where item_type = 'phrase') as phrase_cnt
    from item_data
  )
  select items_json, total, sentence_cnt, word_cnt, phrase_cnt
    into v_items, v_total, v_sentence, v_word, v_phrase
  from item_agg;

  with item_data as (
    select
      si.item_id,
      si.order_index,
      lower(nullif(coalesce(si.snapshot_json->>'type', it.type::text), '')) as item_type,
      coalesce(nullif(si.snapshot_json->>'level', ''), it.level::text) as item_level,
      si.snapshot_json
    from public.session_items si
    left join public.items it on it.id = si.item_id
    where si.session_id = p_session_id
  ), last_attempt as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.latency_ms,
      a.submitted_at,
      g.label,
      g.feedback_short,
      g.minimal_rewrite
    from public.attempts a
    left join public.grades g on g.attempt_id = a.id
    where a.session_id = p_session_id
    order by a.item_id, g.created_at desc nulls last, a.submitted_at desc nulls last, a.id desc
  ), attempt_data as (
    select
      i.item_id,
      i.order_index,
      la.attempt_id,
      la.answer_raw,
      la.label,
      la.feedback_short,
      la.minimal_rewrite,
      la.submitted_at,
      la.latency_ms
    from last_attempt la
    left join public.session_items i on i.session_id = p_session_id and i.item_id = la.item_id
  ), attempt_agg as (
    select
      coalesce(jsonb_agg(jsonb_build_object(
        'item_id', item_id,
        'order_index', order_index,
        'attempt_id', attempt_id,
        'answer', answer_raw,
        'label', label,
        'feedback', feedback_short,
        'minimal_rewrite', minimal_rewrite,
        'submitted_at', submitted_at,
        'latency_ms', latency_ms
      ) order by order_index), '[]'::jsonb) as attempts_json,
      count(*) filter (where label in ('correct', 'variant')) as correct_cnt
    from attempt_data
  ), calendar_agg as (
    select coalesce(jsonb_agg(day order by day), '[]'::jsonb) as calendar_json
    from (
      select distinct to_char((submitted_at at time zone 'Asia/Seoul')::date, 'YYYY-MM-DD') as day
      from attempt_data
      where submitted_at is not null
    ) d
  )
  select attempts_json, correct_cnt, calendar_json
    into v_attempts, v_correct, v_calendar
  from attempt_agg, calendar_agg;

  insert into public.session_bundles (
    user_id,
    bundle_seq,
    started_at,
    ended_at,
    session_ids,
    summary_json
  ) values (
    v_session.user_id,
    v_next_seq,
    v_started,
    v_ended,
    jsonb_build_array(v_session.id),
    jsonb_build_object(
      'metadata', jsonb_build_object(
        'session_id', v_session.id,
        'user_id', v_session.user_id,
        'bundle_seq', v_next_seq,
        'started_at', v_started,
        'ended_at', v_ended,
        'target_item_count', v_session.target_item_count,
        'strategy', coalesce(v_session.strategy_json, '{}'::jsonb)
      ),
      'items', v_items,
      'attempts', v_attempts,
      'metrics', jsonb_build_object(
        'total_items', coalesce(v_total, 0),
        'correct_items', coalesce(v_correct, 0),
        'sentence_count', coalesce(v_sentence, 0),
        'word_count', coalesce(v_word, 0),
        'phrase_count', coalesce(v_phrase, 0),
        'duration_ms', v_duration_ms
      ),
      'calendar', jsonb_build_object(
        'dates', v_calendar
      )
    )
  ) returning id into v_bundle_id;

  insert into public.user_progress_stats (
    user_id, total_attempts, total_correct, updated_at
  ) values (
    v_session.user_id,
    coalesce(v_total, 0),
    coalesce(v_correct, 0),
    now()
  )
  on conflict (user_id) do update
    set total_attempts = public.user_progress_stats.total_attempts + excluded.total_attempts,
        total_correct  = public.user_progress_stats.total_correct  + excluded.total_correct,
        updated_at     = now();

  insert into public.user_recent_bundle_stats (
    user_id, bundle_id, ended_at, total_items, correct_items
  ) values (
    v_session.user_id,
    v_bundle_id,
    v_ended,
    coalesce(v_total, 0),
    coalesce(v_correct, 0)
  )
  on conflict (user_id, bundle_id) do update
    set ended_at = excluded.ended_at,
        total_items = excluded.total_items,
        correct_items = excluded.correct_items;

  delete from public.user_recent_bundle_stats
  where user_id = v_session.user_id
    and bundle_id not in (
      select bundle_id
      from public.user_recent_bundle_stats
      where user_id = v_session.user_id
      order by ended_at desc
      limit 3
    );

  update public.sessions
     set bundle_id = v_bundle_id
   where id = p_session_id;

  delete from public.grades g
   where exists (
     select 1 from public.attempts a
     where a.id = g.attempt_id and a.session_id = p_session_id
   );

  delete from public.attempts a
   where a.session_id = p_session_id;

  delete from public.session_items si
   where si.session_id = p_session_id;

  perform public.truncate_old_bundles(v_session.user_id, 30);

  return v_bundle_id;
end;
$$;

create or replace function public.get_bundle_result(
  p_bundle_id uuid
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();
  _own boolean;
  _result jsonb;
begin
  select exists (
    select 1 from public.session_bundles
    where id = p_bundle_id
      and user_id = _uid
  ) into _own;

  if not coalesce(_own, false) then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  select jsonb_build_object(
           'bundle_id', sb.id,
           'started_at', sb.started_at,
           'ended_at', sb.ended_at,
           'summary', sb.summary_json
         )
    into _result
  from public.session_bundles sb
  where sb.id = p_bundle_id;

  return coalesce(_result, '{}'::jsonb);
end;
$$;

alter table public.session_bundles enable row level security;

drop policy if exists session_bundles_select_own on public.session_bundles;
create policy session_bundles_select_own
  on public.session_bundles
  for select
  using (user_id = auth.uid());

drop policy if exists session_bundles_insert_service on public.session_bundles;
create policy session_bundles_insert_service
  on public.session_bundles
  for insert
  with check (auth.role() = 'service_role');

drop policy if exists session_bundles_update_service on public.session_bundles;
create policy session_bundles_update_service
  on public.session_bundles
  for update
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

drop policy if exists session_bundles_delete_service on public.session_bundles;
create policy session_bundles_delete_service
  on public.session_bundles
  for delete
  using (auth.role() = 'service_role');

commit;
