create or replace function public.get_session_result(p_session_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();            -- 현재 로그인한 사용자
  _own boolean;                       -- 세션 소유 여부
  _result jsonb;                      -- 최종 반환 JSON
begin
  select exists (
    select 1
    from public.sessions s
    where s.id = p_session_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  with si as (
    select id, session_id, item_id, order_index, snapshot_json
    from public.session_items
    where session_id = p_session_id
  ),
  la_graded as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    join public.grades g on g.attempt_id = a.id
    where a.session_id = p_session_id
    order by a.item_id, g.created_at desc nulls last, a.submitted_at desc nulls last, a.id desc
  ),
  la_all as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    where a.session_id = p_session_id
    order by a.item_id, a.submitted_at desc nulls last, a.id desc
  ),
  la as (
    select
      coalesce(g.item_id, a.item_id) as item_id,
      coalesce(g.attempt_id, a.attempt_id) as attempt_id,
      coalesce(g.answer_raw, a.answer_raw) as answer_raw,
      coalesce(g.submitted_at, a.submitted_at) as submitted_at,
      coalesce(g.latency_ms, a.latency_ms) as latency_ms
    from la_all a
    left join la_graded g on g.item_id = a.item_id
  ),
  gr as (
    select attempt_id, label, feedback_short, minimal_rewrite, error_tags
    from public.grades
  ),
  ck as (                             -- 세션 내 등장한 concept_key 목록
    select distinct si.snapshot_json->>'concept_key' as concept_key
    from si
    where si.snapshot_json ? 'concept_key'
  ),
  cm as (                             -- 개념→한글명 매핑
    select c.concept_key, c.display_name, coalesce(c.description, '') as description
    from public.concepts c
    join ck on ck.concept_key = c.concept_key
  ),
  meta as (
    select s.started_at, s.ended_at
    from public.sessions s
    where s.id = p_session_id
  )
  select jsonb_build_object(
    'session_id', p_session_id,
    'started_at', to_char((select started_at from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'ended_at',   to_char((select ended_at   from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'total',      (select count(*) from si),                          -- ★ count(*) 로 교체
    'correct',    coalesce((
                     select count(*)
                     from la
                     join gr on gr.attempt_id = la.attempt_id
                     where gr.label in ('correct','variant')
                   ), 0),
    'items',      coalesce((
                     select jsonb_agg(
                       jsonb_build_object(
                         'order_index',    si.order_index,
                         'item_id',        si.item_id,
                         'question',       si.snapshot_json->>'source_ko',
                         'correct_answer', si.snapshot_json->>'answer_en',
                         'concept_key',    si.snapshot_json->>'concept_key',
                         'concept_ko',     (
                                            select cm.display_name
                                            from cm
                                            where cm.concept_key = si.snapshot_json->>'concept_key'
                                            limit 1
                                          ),
                         'attempt_id',     la.attempt_id,
                         'submitted_at',   to_char(la.submitted_at, 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
                         'latency_ms',     la.latency_ms,
                         'user_answer',    la.answer_raw,
                         'label',          gr.label,
                         'feedback',       gr.feedback_short,
                         'minimal_rewrite',gr.minimal_rewrite
                       )
                       order by si.order_index
                     )
                     from si
                     left join la on la.item_id = si.item_id
                     left join gr on gr.attempt_id = la.attempt_id
                   ), '[]'::jsonb)
  )
  into _result;

  return _result;
end;
$$;

----------------------
create or replace function public.save_grade(
  p_attempt_id uuid,
  p_label grade_label,
  p_feedback text,
  p_minimal_rewrite text,
  p_error_tags text[] default array[]::text[],
  p_judge judge_type default 'rule',
  p_evidence jsonb default '{}'::jsonb
)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();
  _own boolean;
begin
  -- 0) 소유권 검증: 해당 attempt가 현재 사용자 소유 세션인지 확인
  select exists (
    select 1
    from public.attempts a
    join public.sessions s on s.id = a.session_id
    where a.id = p_attempt_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  -- 1) upsert: created_at은 최초 삽입만, 업데이트 시에는 보존
  insert into public.grades (
    attempt_id,
    label,
    feedback_short,
    minimal_rewrite,
    error_tags,
    judge,
    evidence_json,
    created_at
  )
  values (
    p_attempt_id,
    p_label,
    p_feedback,
    p_minimal_rewrite,
    p_error_tags,
    p_judge,
    p_evidence,
    now()
  )
  on conflict (attempt_id) do update
  set label           = excluded.label,
      feedback_short  = excluded.feedback_short,
      minimal_rewrite = excluded.minimal_rewrite,
      error_tags      = excluded.error_tags,
      judge           = excluded.judge,
      evidence_json   = excluded.evidence_json
  ;
end;
$$;

grant execute on function public.save_grade(
  uuid, grade_label, text, text, text[], judge_type, jsonb
) to authenticated;
------------------------
create or replace function complete_session(p_session_id uuid)
returns void as $$
begin
  update public.sessions
  set status = 'completed',
      ended_at = now()
  where id = p_session_id;
end;
$$ language plpgsql;

------------------------


/*
목적

세션 내 채점 결과(grade)를 바탕으로 라이트너 박스를 갱신
단어/구(word/phrase) → user_item_status
문장(sentence) → user_concept_status
같은 문항의 다중 시도가 있을 경우 "마지막(가장 최근) 채점된 시도"만 반영
타입 판정 규칙

session_items.snapshot_json->>'type' (소문자)
items.type::text (소문자)
concept_key 유무로 추정 (있으면 sentence, 없으면 word)
간격표(일)
box 1: 0d, 2: 1d, 3: 3d, 4: 7d, 5: 14d

전제

user_item_status(user_id, item_id) unique

user_concept_status(user_id, concept_key) unique

attempts:grades = 1:1이며, grades.label ∈ ('correct','variant','near_miss','wrong')

본 함수는 SECURITY DEFINER이며, 내부에서 필요한 테이블에 대한 RLS 허용 또는 우회를 보장해야 함
*/

create or replace function public.update_srs(p_session_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  rec record;
  v_is_correct boolean;

  -- item(word/phrase)용
  v_prev_item int;
  v_next_box_item int;
  v_interval_item int;

  -- concept(sentence)용
  v_prev_concept int;
  v_next_box_concept int;
  v_interval_concept int;

  v_item_type text;
begin
  -- 각 문항(item)별 가장 최근 1개 attempt(채점 완료된 것만)만 선별
  for rec in
    with last_per_item as (
      select distinct on (a.item_id)
             a.id as attempt_id
      from public.attempts a
      join public.grades g
        on g.attempt_id = a.id
      where a.session_id = p_session_id
      order by a.item_id,
               g.created_at desc nulls last,
               a.submitted_at desc nulls last,
               a.id desc
    )
    select a.item_id,
           g.label,
           s.user_id,
           si.snapshot_json->>'concept_key' as concept_key
    from last_per_item l
    join public.attempts a on a.id = l.attempt_id
    join public.grades   g on g.attempt_id = a.id
    join public.sessions s on s.id = a.session_id
    join public.session_items si
      on si.session_id = a.session_id
     and si.item_id    = a.item_id
  loop
    v_is_correct := (rec.label in ('correct','variant'));

    -- item 타입 구분: concept_key 존재 시 sentence, 아니면 word/phrase
    if rec.concept_key is not null then
      v_item_type := 'sentence';
    else
      v_item_type := 'word';
    end if;

    -- 1) 단어/구(phrase/word): user_item_status 업데이트
    if v_item_type in ('word','phrase') then
      select box_level into v_prev_item
      from public.user_item_status
      where user_id = rec.user_id
        and item_id = rec.item_id;

      if v_is_correct then
        v_next_box_item := least(coalesce(v_prev_item, 0) + 1, 5);
      else
        v_next_box_item := 1;
      end if;

      v_interval_item := case v_next_box_item
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_item_status(
        user_id, item_id, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.item_id, v_next_box_item, now(), now() + make_interval(days => v_interval_item),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, item_id) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_item_status.streak         + excluded.streak,
            total_attempts  = public.user_item_status.total_attempts + 1,
            correct_count   = public.user_item_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_item_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;

    -- 2) 문장(sentence): user_concept_status 업데이트
    if v_item_type = 'sentence' and rec.concept_key is not null then
      select box_level into v_prev_concept
      from public.user_concept_status
      where user_id = rec.user_id
        and concept_key = rec.concept_key;

      if v_is_correct then
        v_next_box_concept := least(coalesce(v_prev_concept, 0) + 1, 5);
      else
        v_next_box_concept := 1;
      end if;

      v_interval_concept := case v_next_box_concept
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_concept_status(
        user_id, concept_key, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.concept_key, v_next_box_concept, now(), now() + make_interval(days => v_interval_concept),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, concept_key) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_concept_status.streak         + excluded.streak,
            total_attempts  = public.user_concept_status.total_attempts + 1,
            correct_count   = public.user_concept_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_concept_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;
  end loop;

  return;
end;
$$;


---------------------------
create or replace function submit_attempt(
  p_session_id uuid,
  p_item_id uuid,
  p_answer_raw text,
  p_latency_ms int
)
returns uuid as $$
declare
  v_attempt_id uuid;
begin
  insert into public.attempts(session_id, item_id, answer_raw, latency_ms)
  values (p_session_id, p_item_id, p_answer_raw, p_latency_ms)
  returning id into v_attempt_id;

  return v_attempt_id;
end;
$$ language plpgsql;

-----------------------------
-- 파일/역할: DB 함수 / 출제+세션생성+스냅샷 동결
-- 의존: policy_level_mix, policy_type_weights, policy_thresholds, users, items,
--       attempts, user_item_status, user_concept_status, sessions, session_items
-- 주의: SECURITY DEFINER + search_path 고정

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,        -- 'new_only' | 'mix' | 'review_only' | 'weak_focus'
  p_count int default null    -- null이면 정책의 default_session_size 사용
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;              -- users.current_level (정수 레벨)
  v_level_mix jsonb;                -- {"1":0.8,"2":0.2}
  v_type_weights jsonb;             -- {"review":0.5,"new":0.3,"weak":0.2}

  v_level_attempts int;
  v_effective_type session_type;
  v_underfilled boolean := false;

  -- 목표 수량
  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

begin
  -- 0) 정책 로드
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) 사용자 현재 레벨 & 레벨 믹스
  select coalesce(u.current_level, 1) into v_current_level
  from users u where u.id = p_user_id;

  select plm.level_weights into v_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_level_mix is null then
    v_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- 2) 타입별 비율
  select ptw.weights into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) 레벨별 누적 풀이수 (스냅샷 level 정수 기준)
  select coalesce(count(*),0) into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  -- 4) 임계 가드
  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 5) 타입별 목표 수량 산출
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor( (v_type_weights->>'review')::numeric * v_count )::int;
    tgt_new    := floor( (v_type_weights->>'new')::numeric    * v_count )::int;
    tgt_weak   := floor( (v_type_weights->>'weak')::numeric   * v_count )::int;
    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1; -- mix의 잔여는 review 우선 보충
      end if;
    end loop;
  end if;

  -- =========================
  -- 후보 풀 계산 → 임시테이블에 최종 ID 저장
  -- =========================
  -- (세션이 끝나면 자동 드롭되도록 on commit drop)
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_level_mix)
    order by 1
  ),
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select ri.id
    from review_items ri
    join lvl on lvl.lvl = ri.level
    order by ri.is_due desc, ri.due_at asc, ri.created_at desc
    limit tgt_review
  ),
  pick_weak as (
    select wi.id
    from weak_items wi
    join lvl on lvl.lvl = wi.level
    order by wi.wscore desc, wi.maxw desc
    limit tgt_weak
  ),
  pick_new as (
    select ni.id
    from new_items ni
    join lvl on lvl.lvl = ni.level
    order by ni.created_at desc
    limit tgt_new
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    where pd.id is null
      and i.status in ('draft','approved')
    order by i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  ) f;

  -- 6) 세션 생성 (전략 기록에 tmp_final_ids 개수 사용)
  insert into public.sessions(user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled',      (select count(*) from tmp_final_ids),
      'level_mix',   v_level_mix
    )
  )
  returning id into v_session_id;

  -- 7) 스냅샷 동결 (tmp_final_ids 재사용)
  insert into public.session_items(session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,  -- 정수로 저장 보증
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;
----------------------------------
create or replace function public.get_concepts_ko(p_keys text[])
returns table (concept_key text, display_name text, description text)
language sql
security definer
set search_path = public
as $$
with src as (
select concept_key, display_name, coalesce(description, '') as description
from public.concepts
where concept_key = any(p_keys)
)
select concept_key, display_name, description from src;
$$;

grant execute on function public.get_concepts_ko(text[]) to authenticated;
-------------------------
-- 경로: supabase/migrations/20250916_level_functions.sql
-- 역할: 레벨 통계·판정·세션 생성 함수 정의
-- 의존관계: users, sessions, attempts, grades, user_concept_status, items, policy_level_* 테이블, policy_thresholds, policy_type_weights
-- 포함 함수: normalize_level_mix, get_user_level_stats, get_difficulty_adjustment, evaluate_user_level_progress, auto_level_up, start_session_custom

set check_function_bodies = on;

create or replace function normalize_level_mix(p_mix jsonb)
returns jsonb
language plpgsql
immutable
as $$
declare
  v_total numeric := 0;
  v_result jsonb := '{}'::jsonb;
  v_key text;
  v_val numeric;
begin
  if p_mix is null then
    return '{}'::jsonb;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_total := v_total + v_val;
    end if;
  end loop;

  if v_total <= 0 then
    return p_mix;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_result := v_result || jsonb_build_object(v_key, round((v_val / v_total)::numeric, 4));
    end if;
  end loop;

  return v_result;
end;
$$;
-- normalize_level_mix: 레벨 분포 JSON 합계 1.0 정규화

create or replace function get_user_level_stats(p_user_id uuid)
returns table (
  recent_session_id uuid,
  recent_session_started_at timestamptz,
  recent_session_ended_at timestamptz,
  recent_attempts int,
  recent_correct_attempts int,
  recent_correct_rate numeric,
  total_attempts bigint,
  stable_concept_count bigint,
  stable_concept_ratio numeric,
  low_box_concept_count bigint
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_total_concepts bigint;
begin
  select s.id, s.started_at, s.ended_at
  into recent_session_id, recent_session_started_at, recent_session_ended_at
  from sessions s
  where s.user_id = p_user_id
    and s.status = 'completed'
  order by coalesce(s.ended_at, s.started_at) desc
  limit 1;

  if recent_session_id is not null then
    select count(*)::int
    into recent_attempts
    from attempts a
    where a.session_id = recent_session_id;

    select count(*)::int
    into recent_correct_attempts
    from attempts a
    join grades g on g.attempt_id = a.id
    where a.session_id = recent_session_id
      and g.label in ('correct', 'variant');

    recent_correct_rate :=
      case when recent_attempts > 0
           then round((recent_correct_attempts::numeric / recent_attempts)::numeric, 4)
           else 0 end;
  else
    recent_attempts := 0;
    recent_correct_attempts := 0;
    recent_correct_rate := 0;
  end if;

  select coalesce(sum(ucs.total_attempts), 0)
  into total_attempts
  from user_concept_status ucs
  where ucs.user_id = p_user_id;

  select coalesce(count(*), 0)
  into stable_concept_count
  from user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level >= 4;

  select coalesce(count(*), 0)
  into v_total_concepts
  from user_concept_status ucs
  where ucs.user_id = p_user_id;

  stable_concept_ratio :=
    case when v_total_concepts > 0
         then round((stable_concept_count::numeric / v_total_concepts)::numeric, 4)
         else 0 end;

  select coalesce(count(*), 0)
  into low_box_concept_count
  from user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level <= 2;

  return next;
end;
$$;

-- get_user_level_stats: 최근 세션·개념 집계 반환


create or replace function get_difficulty_adjustment(p_user_id uuid)
returns table (
  applied boolean,
  reason text,
  policy_level int,
  recent_correct_rate numeric,
  low_box_concept_count bigint,
  adjusted_mix jsonb
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_level int;
  v_condition jsonb;
  v_threshold_rate numeric;
  v_threshold_low int;
begin
  select current_level
  into v_level
  from users
  where id = p_user_id;

  if v_level is null then
    applied := false;
    reason := '사용자 레벨 정보 없음';
    policy_level := null;
    recent_correct_rate := 0;
    low_box_concept_count := 0;
    adjusted_mix := null;
    return next;
  end if;

  policy_level := v_level;

  -- 최근 정답률
  with recent_sessions as (
    select s.id
    from sessions s
    where s.user_id = p_user_id
      and s.status = 'completed'
    order by coalesce(s.ended_at, s.started_at) desc
    limit 3
  ),
  recent_attempts as (
    select a.id
    from attempts a
    where a.session_id in (select id from recent_sessions)
  ),
  recent_labels as (
    select g.label
    from grades g
    join recent_attempts a on a.id = g.attempt_id
  )
  select case
           when count(*) > 0 then round((count(*) filter (where label in ('correct','variant'))::numeric / count(*))::numeric, 4)
           else 0
         end
  into recent_correct_rate
  from recent_labels;

  -- 낮은 박스 개수
  select coalesce(gs.low_box_concept_count, 0)
  into low_box_concept_count
  from get_user_level_stats(p_user_id) as gs;

  select condition_json, adjusted_mix_json
  into v_condition, adjusted_mix
  from policy_level_adjustments
  where level = v_level;

  if v_condition is null or adjusted_mix is null then
    applied := false;
    reason := '조정 정책 없음';
    adjusted_mix := null;
    return next;
  end if;

  v_threshold_rate := coalesce((v_condition->>'recent_correct_rate_below')::numeric, 0.6);
  v_threshold_low := coalesce((v_condition->>'low_box_concepts_over')::int, 5);

  if recent_correct_rate < v_threshold_rate
     and low_box_concept_count >= v_threshold_low then
    applied := true;
    reason := format('최근 정답률 %.2f < 정책 %.2f, 낮은 박스 %s ≥ %s',
                     recent_correct_rate, v_threshold_rate,
                     low_box_concept_count, v_threshold_low);
    adjusted_mix := normalize_level_mix(adjusted_mix);
  else
    applied := false;
    reason := '조건 미충족';
    adjusted_mix := null;
  end if;

  return next;
end;
$$;


-- get_difficulty_adjustment: 최근 성과 기반 난이도 조정 판정

create or replace function evaluate_user_level_progress(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_current int;
  v_target int;
  v_policy policy_level_up%rowtype;
  v_stats record;
  v_pass boolean := false;
  v_reason text := '';
begin
  select current_level
  into v_current
  from users
  where id = p_user_id;

  if v_current is null then
    return jsonb_build_object(
      'eligible', false,
      'reason', '레벨 정보 없음'
    );
  end if;

  v_target := v_current + 1;

  select * into v_policy
  from policy_level_up
  where level = v_target;

  if not found then
    return jsonb_build_object(
      'eligible', false,
      'reason', '다음 레벨 정책 미정의',
      'current_level', v_current,
      'target_level', v_target
    );
  end if;

  select * into v_stats
  from get_user_level_stats(p_user_id);

  if coalesce(v_stats.total_attempts, 0) < v_policy.min_total_attempts then
    v_reason := format('누적 시도수 %s < %s',
                       coalesce(v_stats.total_attempts, 0),
                       v_policy.min_total_attempts);
  elsif coalesce(v_stats.recent_correct_rate, 0) < v_policy.min_correct_rate then
    v_reason := format('최근 정답률 %.2f < %.2f',
                       coalesce(v_stats.recent_correct_rate, 0),
                       v_policy.min_correct_rate);
  elsif coalesce(v_stats.stable_concept_ratio, 0) < v_policy.min_box_level_ratio then
    v_reason := format('안정 비율 %.2f < %.2f',
                       coalesce(v_stats.stable_concept_ratio, 0),
                       v_policy.min_box_level_ratio);
  else
    v_pass := true;
    v_reason := '정책 충족';
  end if;

  return jsonb_build_object(
    'eligible', v_pass,
    'reason', v_reason,
    'current_level', v_current,
    'target_level', v_target,
    'stats', to_jsonb(v_stats)
  );
end;
$$;
-- evaluate_user_level_progress: 승급 가능 여부 판정

create or replace function auto_level_up(p_user_id uuid, p_source text default 'auto_assessment')
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_eval jsonb;
  v_eligible boolean;
  v_target int;
  v_new_level int;
begin
  v_eval := evaluate_user_level_progress(p_user_id);
  v_eligible := coalesce((v_eval->>'eligible')::boolean, false);
  v_target := (v_eval->>'target_level')::int;

  if not v_eligible then
    return jsonb_build_object(
      'leveled_up', false,
      'reason', v_eval->>'reason',
      'current_level', v_eval->>'current_level'
    );
  end if;

  update users
  set current_level = v_target
  where id = p_user_id
  returning current_level
  into v_new_level;

  insert into user_level_history (user_id, level, source)
  values (p_user_id, v_new_level, coalesce(p_source, 'auto_assessment'));

  return jsonb_build_object(
    'leveled_up', true,
    'new_level', v_new_level,
    'source', coalesce(p_source, 'auto_assessment')
  );
end;
$$;
-- auto_level_up: 승급 처리 및 이력 기록
------------------------------------
create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,
  p_count int default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;
  v_base_level_mix jsonb;
  v_applied_level_mix jsonb;
  v_type_weights jsonb;

  v_level_attempts int;
  v_effective_type session_type;

  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

  v_adjust record;
  v_stats record;

  v_remaining int;
  v_level_arr int[];
  v_arr_len int;
  i int;
  v_result_level_mix jsonb := '{}'::jsonb;
begin
  -- 0) 정책 임계값 로드
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) 현재 레벨과 기본 레벨 믹스 로드
  select coalesce(u.current_level, 1)
  into v_current_level
  from users u
  where u.id = p_user_id;

  select plm.level_weights
  into v_base_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_base_level_mix is null then
    v_base_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- 난이도 보정 적용
  select * into v_adjust
  from get_difficulty_adjustment(p_user_id);

  if v_adjust.applied and v_adjust.adjusted_mix is not null then
    v_applied_level_mix := v_adjust.adjusted_mix;
  else
    v_applied_level_mix := v_base_level_mix;
  end if;

  v_applied_level_mix := normalize_level_mix(v_applied_level_mix);

  -- 2) 타입(복습/신규/취약) 비중 로드
  select ptw.weights
  into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) 현재 레벨 학습 이력 체크 → 강제 신규 여부 판단
  select coalesce(count(*),0)
  into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 4) 타입별 목표 개수 산정
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor((coalesce(v_type_weights->>'review','0'))::numeric * v_count)::int;
    tgt_new    := floor((coalesce(v_type_weights->>'new','0'))::numeric    * v_count)::int;
    tgt_weak   := floor((coalesce(v_type_weights->>'weak','0'))::numeric   * v_count)::int;

    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1;
      end if;
    end loop;
  end if;

  -- 5) 레벨 믹스에 따른 목표 수량 계산 (총합)
  drop table if exists tmp_level_targets;
  create temporary table tmp_level_targets (
    level int primary key,
    weight numeric,
    total_target int default 0
  ) on commit drop;

  insert into tmp_level_targets(level, weight, total_target)
  select lvl, weight, floor(weight * v_count)::int
  from (
    select (key)::int as lvl, (value)::numeric as weight
    from jsonb_each(v_applied_level_mix)
  ) s
  order by weight desc, lvl;

  select array_agg(level order by weight desc, level asc)
  into v_level_arr
  from tmp_level_targets;

  v_arr_len := coalesce(array_length(v_level_arr, 1), 0);

  select v_count - coalesce(sum(total_target), 0)
  into v_remaining
  from tmp_level_targets;

  if v_remaining > 0 and v_arr_len > 0 then
    for i in 0..(v_remaining - 1) loop
      update tmp_level_targets
      set total_target = total_target + 1
      where level = v_level_arr[(i % v_arr_len) + 1];
    end loop;
  end if;

  -- 6) 타입별 목표를 레벨별로 분배
  drop table if exists tmp_target_review;
  drop table if exists tmp_target_new;
  drop table if exists tmp_target_weak;

  create temporary table tmp_target_review(
    level int primary key,
    target int default 0
  ) on commit drop;

  create temporary table tmp_target_new(
    level int primary key,
    target int default 0
  ) on commit drop;

  create temporary table tmp_target_weak(
    level int primary key,
    target int default 0
  ) on commit drop;

  insert into tmp_target_review(level, target)
  select level,
         case when tgt_review > 0 then floor(weight * tgt_review)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  insert into tmp_target_new(level, target)
  select level,
         case when tgt_new > 0 then floor(weight * tgt_new)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  insert into tmp_target_weak(level, target)
  select level,
         case when tgt_weak > 0 then floor(weight * tgt_weak)::int else 0 end
  from tmp_level_targets
  order by weight desc, level;

  if tgt_review > 0 and v_arr_len > 0 then
    select tgt_review - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_review;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_review
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  if tgt_new > 0 and v_arr_len > 0 then
    select tgt_new - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_new;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_new
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  if tgt_weak > 0 and v_arr_len > 0 then
    select tgt_weak - coalesce(sum(target),0)
    into v_remaining
    from tmp_target_weak;

    if v_remaining > 0 then
      for i in 0..(v_remaining - 1) loop
        update tmp_target_weak
        set target = target + 1
        where level = v_level_arr[(i % v_arr_len) + 1];
      end loop;
    end if;
  end if;

  -- 7) 후보 아이템 선발
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select result.id, tr.level
    from tmp_target_review tr
    cross join lateral (
      select ri.id
      from review_items ri
      where ri.level = tr.level
      order by (case when v_review_due_first then ri.is_due else 0 end) desc,
               (case when v_review_due_first then ri.due_at else ri.created_at end) asc
      limit tr.target
    ) result
  ),
  pick_weak as (
    select result.id, tw.level
    from tmp_target_weak tw
    cross join lateral (
      select wi.id
      from weak_items wi
      where wi.level = tw.level
        and ((not v_weak_requires_history) or wi.maxw > 0)
      order by wi.wscore desc, wi.maxw desc
      limit tw.target
    ) result
  ),
  pick_new as (
    select result.id, tn.level
    from tmp_target_new tn
    cross join lateral (
      select ni.id
      from new_items ni
      where ni.level = tn.level
      order by ni.created_at desc
      limit tn.target
    ) result
  ),
  picked as (
    select id, level from pick_review
    union all
    select id, level from pick_weak
    union all
    select id, level from pick_new
  ),
  picked_ranked as (
    select id, level,
           row_number() over (partition by id order by level) as rn
    from picked
  ),
  picked_dedup as (
    select id, level
    from picked_ranked
    where rn = 1
  ),
  current_level_counts as (
    select level, count(*) as picked
    from picked_dedup
    group by level
  ),
  level_slots as (
    select t.level,
           t.total_target,
           t.weight,
           coalesce(c.picked, 0) as picked
    from tmp_level_targets t
    left join current_level_counts c on c.level = t.level
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    left join level_slots ls on ls.level = i.level
    where pd.id is null
      and i.status in ('draft','approved')
    order by coalesce(ls.total_target - ls.picked, 0) desc,
             coalesce(ls.weight, 0) desc,
             i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  ),
  final_ids as (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  )
  select id from final_ids;

  -- 8) 사용자 통계 스냅샷
  select * into v_stats
  from get_user_level_stats(p_user_id);

  -- 실제 출제된 레벨 비중 계산
  if v_count > 0 then
    select coalesce(
      jsonb_object_agg(level::text, cnt::numeric / v_count),
      '{}'::jsonb
    )
    into v_result_level_mix
    from (
      select i.level, count(*) as cnt
      from items i
      join tmp_final_ids t on t.id = i.id
      group by i.level
    ) sub;
  else
    v_result_level_mix := '{}'::jsonb;
  end if;

  -- 9) 세션 생성 및 전략 기록
  insert into public.sessions (user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled', (select count(*) from tmp_final_ids),
      'base_level_mix', v_base_level_mix,
      'applied_level_mix', v_applied_level_mix,
      'selected_level_mix', v_result_level_mix,
      'adjustment', jsonb_build_object(
        'applied', coalesce(v_adjust.applied, false),
        'reason', coalesce(v_adjust.reason, ''),
        'policy_level', v_adjust.policy_level,
        'recent_correct_rate', v_adjust.recent_correct_rate,
        'low_box_concept_count', v_adjust.low_box_concept_count
      ),
      'stats_snapshot', to_jsonb(v_stats)
    )
  )
  returning id into v_session_id;

  -- 10) 세션 아이템 스냅샷 저장
  insert into public.session_items (session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;

-----------------------
-- 0) 준비: UUID 생성용
create extension if not exists pgcrypto;

-- 1) 공통 updated_at 트리거 (중복 생성 방지)
create or replace function public.touch_updated_at()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

-- 2) products: 판매 상품 정의
create table if not exists public.products (
  id text primary key,
  display_name text not null,
  list_price_krw integer not null check (list_price_krw >= 0),
  launch_price_krw integer not null check (launch_price_krw >= 0),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger trg_products_updated_at
before update on public.products
for each row execute function public.touch_updated_at();

-- 3) payments: 결제 요청/응답 단건
create table if not exists public.payments (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  provider text not null default 'payapp',
  provider_tx_id text unique,
  amount_krw integer not null check (amount_krw > 0),
  status text not null check (status in ('pending','paid','failed','canceled','refunded')),
  requested_at timestamptz not null default now(),
  paid_at timestamptz,
  canceled_at timestamptz,
  meta_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_payments_user_id on public.payments(user_id);
create index idx_payments_product_id on public.payments(product_id);
create index idx_payments_status on public.payments(status);

create trigger trg_payments_updated_at
before update on public.payments
for each row execute function public.touch_updated_at();

-- 4) payment_events: 웹훅 및 상태 변경 로그
create table if not exists public.payment_events (
  id uuid primary key default gen_random_uuid(),
  payment_id uuid not null references public.payments(id) on delete cascade,
  event_type text not null,
  payload_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index idx_payment_events_payment_id on public.payment_events(payment_id);
create index idx_payment_events_event_type on public.payment_events(event_type);

-- 5) entitlements: 이용권(권리) 테이블
create table if not exists public.entitlements (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  payment_id uuid not null references public.payments(id) on delete cascade,
  start_at timestamptz not null,
  end_at timestamptz not null,
  is_active boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(payment_id)
);

create index idx_entitlements_user_id on public.entitlements(user_id);
create index idx_entitlements_active on public.entitlements(is_active);
create index idx_entitlements_end_at on public.entitlements(end_at);

-- is_active 갱신 + users.pro_until 캐시 반영용 함수/트리거
create or replace function public.entitlements_after_change()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_latest_until timestamptz;
begin
  -- is_active: start_at <= now() < end_at 조건에 따라 갱신
  if (TG_OP = 'INSERT' or TG_OP = 'UPDATE') then
    if new.start_at <= now() and new.end_at > now() then
      new.is_active := true;
    else
      new.is_active := false;
    end if;
  end if;

  -- 사용자 pro_until 캐시 업데이트(선택 필드가 존재할 때만)
  begin
    select max(end_at) into v_latest_until
    from public.entitlements
    where user_id = new.user_id;

    update public.users
    set pro_until = v_latest_until
    where id = new.user_id;
  exception when undefined_column then
    -- users.pro_until 컬럼이 없으면 무시
    null;
  end;

  return new;
end;
$$;

create trigger trg_entitlements_upsert
before insert or update on public.entitlements
for each row execute function public.entitlements_after_change();

create trigger trg_entitlements_updated_at
before update on public.entitlements
for each row execute function public.touch_updated_at();

-- 5-1) users 테이블에 pro_until 캐시 컬럼 추가 (선택)
alter table public.users
  add column if not exists pro_until timestamptz;

-- 6) 세션 시작 가드 함수 (무료 1회 + 이용권 체크)
create or replace function public.can_start_session(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_today date := (timezone('Asia/Seoul', now()))::date;
  v_completed_today integer;
  v_pro_until timestamptz;
  v_has_entitlement boolean;
  v_can_start boolean := false;
  v_reason text := 'NO_FREE_LEFT';
begin
  -- 오늘 완료된 세션 수
  select count(*) into v_completed_today
  from public.sessions
  where user_id = p_user_id
    and status = 'completed'
    and (timezone('Asia/Seoul', ended_at))::date = v_today;

  -- 활성 이용권 여부
  select exists (
    select 1
    from public.entitlements
    where user_id = p_user_id
      and end_at > now()
      and start_at <= now()
  ) into v_has_entitlement;

  -- pro_until 캐시 (없으면 null)
  begin
    select pro_until into v_pro_until
    from public.users where id = p_user_id;
  exception when undefined_column then
    v_pro_until := null;
  end;

  if v_has_entitlement or (v_pro_until is not null and v_pro_until > now()) then
    v_can_start := true;
    v_reason := 'OK_WITH_PRO';
  elsif v_completed_today < 1 then
    v_can_start := true;
    v_reason := 'OK_WITH_FREE';
  end if;

  return jsonb_build_object(
    'can_start', v_can_start,
    'reason', v_reason,
    'free_sessions_used_today', v_completed_today,
    'pro_until', v_pro_until
  );
end;
$$;

-- 7) RLS 정책 설정
alter table public.products enable row level security;
alter table public.payments enable row level security;
alter table public.payment_events enable row level security;
alter table public.entitlements enable row level security;

-- products: 누구나 active 상품만 조회 가능(선택적으로 공개)
drop policy if exists products_select_active on public.products;
create policy products_select_active
on public.products
for select
using (is_active = true);

-- payments: 본인은 자신의 결제만 조회
drop policy if exists payments_select_own on public.payments;
create policy payments_select_own
on public.payments
for select
using (auth.uid() = user_id);

-- payment_events: 본인 결제 로그만 조회
drop policy if exists payment_events_select_own on public.payment_events;
create policy payment_events_select_own
on public.payment_events
for select
using (
  auth.uid() = (
    select user_id from public.payments where id = payment_id
  )
);

-- entitlements: 본인 권리만 조회
drop policy if exists entitlements_select_own on public.entitlements;
create policy entitlements_select_own
on public.entitlements
for select
using (auth.uid() = user_id);

-- 서비스 롤 전용 전체 권한 (INSERT/UPDATE/DELETE)
drop policy if exists payments_service_all on public.payments;
create policy payments_service_all
on public.payments
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists payment_events_service_all on public.payment_events;
create policy payment_events_service_all
on public.payment_events
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists entitlements_service_all on public.entitlements;
create policy entitlements_service_all
on public.entitlements
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- (필요 시) products 수정도 서비스 롤만 허용
drop policy if exists products_service_all on public.products;
create policy products_service_all
on public.products
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');
--------------------