좋아요. **코드 없이**, 바로 구현에 쓸 수 있게 “해야 할 일 목록”으로 정리해둘게요.

# SQL 함수(또는 뷰) — 새로 만들/수정할 것

## 1) 세션 시작/출제

* **새 함수**: `start_session_custom(p_user_id, p_type, p_count)`

  * 역할: 출제 정책을 **DB에서** 적용해 문제를 선별하고, `sessions` 생성 + `session_items.snapshot_json`에 **스냅샷 동결**까지 처리.
  * 정책 포함:

    * 타입: `new_only | mix | review_only | weak_focus` (4가지)
    * 레벨 배합: “현재 레벨 중심 + 인접 레벨 소량” 비율(정책 테이블로 참조)
    * **라이트너 연계**: `user_item_status/user_concept_status`의 `next_due_at`가 **지금 시각 이전**(due) 우선
    * **약점**: `wrong_count`/`last_result in (wrong, near_miss)` 우선
    * **풀이량 가드**: “레벨별 누적 풀이 < 300”이면 **강제로 `new_only`**
  * 보안: `SECURITY DEFINER` + `search_path=public`, 실행권한 `authenticated`(함수 내부에서 RLS 우회).
  * 스냅샷 필드: `id,type,level,difficulty,concept_key,source_ko,answer_en,allowed_variants_text,near_misses_text`(현 사양 유지).

> 현 함수 `start_session(p_user_id, p_count)`는 “최신 item 기준 출제”라 정책 미적용 상태. 새 함수로 대체/병행 권장.

## 2) 후보 선별 유틸(선택)

* **뷰/함수(선택)**: `get_candidates(p_user_id, p_type, p_level, p_limit)`

  * 역할: due·약점·신규 후보 집합만 반환(선별 로직을 모듈화).
  * `start_session_custom`에서 호출해 구성 단순화.
  * 운영 편의를 위해 **정책 테이블**(예: `policy_level_mix`, `policy_type_weights`)을 참조하도록 설계 → 함수 수정 없이 값 변경만으로 운영.

## 3) 채점/라이트너 연동(기존 유지, 사용 위치 명확화)

* **`save_grade(p_attempt_id, …)`**: 피드백·라벨 저장(그레이드) — 이미 있음.
* **`update_srs(p_session_id)`**: 라이트너 박스 갱신(맞음 상향, 틀림 1번/간격표 반영) — 이미 있음.

  * 호출 타이밍: **세션 내 문항 채점이 끝난 후**(또는 배치/훅으로 트리거).
* **`complete_session(p_session_id)`**: 세션 종료 — 이미 있음.

## 4) RLS/권한 체크(변경 필요 없음, 호출만 주의)

* `session_items` **insert는 사용자 금지** → 함수/서버만 가능(지금 정책과 합치).
* 함수들은 `SECURITY DEFINER`로 실행·권한 부여(이미 가이드 존재).

---

# 웹(프론트/서버) — 수정/추가 포인트

## 1) API 라우트(서버)

* **`POST /api/sessions`**

  * 입력: `{ user_id, type, count }`
  * 동작: 서버에서 Supabase **RPC로 `start_session_custom` 호출** → `session_id`와 스냅샷 목록 반환.
  * 주의: **service role 키는 서버에서만** 사용(클라이언트 노출 금지).
  * 근거: 세션/스냅샷/사이클 계약 정의가 이미 있음.
* **`POST /api/attempts` → `POST /api/grades` → (옵션) `POST /api/srs/update` → `POST /api/sessions/:id/complete`**

  * 현 스펙대로 연결(룰 채점 우선, 필요 시 SRS 갱신 호출).

## 2) 학습 시작 플로우(UI)

* **세션 타입 선택 UI**: `components/dashboard/session-type-modal.tsx`

  * 변경: 4가지 타입 노출 + 현재 레벨별 풀이량(<300)일 때는 **`new_only` 고정** 안내/비활성 처리.
* **세션 시작 카드**: `components/dashboard/start-learning-card.tsx`

  * 변경: 선택된 타입·문항수로 `/api/sessions` 호출하도록 연결.

## 3) 학습 화면(풀이)

* **`app/learn/page.tsx` + `components/learn/problem-card.tsx` / `answer-input.tsx` / `feedback-display.tsx`**

  * 스냅샷 기반으로 문제 표시.
  * 제출 시 `/api/attempts` → `/api/grades` 진행, 세션 끝나면 `update_srs` 호출(또는 세션 완료 시 일괄).
  * 라이트너/약점 정책은 **DB가 이미 반영**하므로 UI는 단순.

## 4) 이력/다시풀기(연습 모드)

* **`app/history/[sessionId]/page.tsx` + `components/history/replay-item.tsx`**

  * 스냅샷으로 재현, **attempts/grades/SRS 기록하지 않음**(연습용) — 지금 설계와 합치.

## 5) 대시보드/약점·우선개념

* **`components/dashboard/weak-concepts.tsx` / `priority-concepts.tsx`**

  * 데이터 소스: `user_item_status`/`user_concept_status`의 `wrong_count`, `next_due_at` 등.
  * 출제 정책과 자연스런 연계(약점·due 가시화) — 기획서 플로우와 일치.

## 6) 레벨/레벨업 표시

* **`components/dashboard/level-card.tsx`**

  * 현재 레벨(`users.current_level`) 표시.
  * 레벨업 시 `user_level_history`에 기록(정책 자체는 후순위 단순판정으로 시작 가능).

## 7) 온보딩 가드(선택)

* **`app/onboarding/page.tsx` / 라우팅 가드**

  * `current_level` 없으면 온보딩 → 이후 대시보드 — 문서 가이드 존재.

--

# 📘 정책 테이블 설명 문서

## 1) `policy_level_mix` (레벨 믹스 정책)

* **목적:** 현재 레벨 학습자가 어떤 비율로 인접 레벨 문제를 섞어 풀지 정의.
* **구조:**

  * `level` (int): 기준이 되는 현재 레벨 (예: 1=L1, 2=L2, …).
  * `level_weights` (jsonb): 출제 비율. 예: `{ "1":0.7, "2":0.2, "3":0.1 }`
  * `note`: 설명 메모.
* **사용:**

  * 출제 함수(`start_session_custom`)에서 사용자의 `current_level`을 읽고, 해당 비율대로 문항 분포를 맞춤.
  * **재고가 없는 레벨은 자동 0% 처리 후 재분배.**
* **운영 예시:**

  * L1 학습자 → L1:80%, L2:20%
  * L3 학습자 → L2:15%, L3:70%, L4:15%

---

## 2) `policy_type_weights` (출제 타입별 가중치 정책)

* **목적:** 출제 타입(`new_only | mix | review_only | weak_focus`)마다 신규/복습/약점 문제 비율을 정의.
* **구조:**

  * `session_type` (enum): 세션 타입 값.
  * `weights` (jsonb): 카테고리 비율. 예: `{ "new":0.3, "review":0.5, "weak":0.2 }`
  * `note`: 설명 메모.
* **사용:**

  * `start_session_custom`가 호출될 때, 입력된 `p_type`에 맞는 비율을 불러와 문항을 분배.
* **운영 예시:**

  * `new_only`: 신규=100%
  * `mix`: 복습=50%, 신규=30%, 약점=20%
  * `review_only`: 복습=80%, 약점=20%
  * `weak_focus`: 약점=60%, 신규=40%

---

## 3) `policy_thresholds` (임계·기본값 정책)

* **목적:** 전역 임계치와 기본값을 관리해 출제 로직을 통제.
* **구조:**

  * `per_level_min_attempts_for_review` (int): 특정 레벨에서 최소 몇 문항 풀어야 복습/약점 모드를 허용할지. (기본=300)
  * `default_session_size` (int): 세션 기본 문항 수 (기본=10).
  * `min_session_size` / `max_session_size`: 최소/최대 문항 수 (예: 1\~20).
  * `force_new_when_below_threshold` (bool): 임계 미달 시 강제로 신규 모드만 허용 여부.
  * `review_due_first` (bool): 복습 문제는 항상 due된 문제를 우선할지 여부.
  * `weak_requires_history` (bool): 약점 문제는 최소 1회 시도 이력이 있어야 인정할지 여부.
  * `note`: 설명 메모.
* **사용:**

  * 사용자가 레벨별 누적 풀이 <300이면 자동으로 `new_only` 강제.
  * 세션 문항 수 기본값/최소·최대 제한 적용.
  * 약점/복습 문제 선발 시 필터 조건으로 활용.

---

# ✅ 정리

* **`policy_level_mix`** → *레벨별 문항 분포 전략*
* **`policy_type_weights`** → *세션 타입별 신규/복습/약점 비율*
* **`policy_thresholds`** → *출제·학습 임계치/기본값 관리*

👉 이 세 가지 정책 테이블을 분리해두면, **함수는 고정**하고 **운영팀이 테이블 값만 수정**해도 출제 전략이 즉시 반영됩니다.



