# ë°±ì—”ë“œ ë£¨í”„ ìë™í™” í•¨ìˆ˜ ì‚¬ì–‘ì„œ (Postgres Functions)

## 0) ì›ì¹™

* ëª¨ë“  í•¨ìˆ˜ëŠ” **SQL Editor â†’ Function** ìœ¼ë¡œ ìƒì„±.
* í”„ë¡ íŠ¸ì—”ë“œ(API)ì—ì„œëŠ” í•¨ìˆ˜ë§Œ í˜¸ì¶œí•˜ë©´ ë¨.
* **ë¼ì´íŠ¸ë„ˆ ë°•ìŠ¤ ê·œì¹™** ë°˜ì˜:

  * Box 1 = ë‹¹ì¼, Box 2 = +1ì¼, Box 3 = +3ì¼, Box 4 = +7ì¼, Box 5 = +14ì¼
  * ë§ìŒ(correct/variant) â†’ box +1 (ìµœëŒ€ 5)
  * í‹€ë¦¼(wrong/near\_miss) â†’ box = 1
  * **ë¬¸ì¥(concept)** ì€ `user_concept_status`, **ë‹¨ì–´/phrase(item)** ëŠ” `user_item_status`

---

## 1. ì„¸ì…˜ ì‹œì‘ (ì¶œì œ)

-- íŒŒì¼/ì—­í• : DB í•¨ìˆ˜ / ì¶œì œ+ì„¸ì…˜ìƒì„±+ìŠ¤ëƒ…ìƒ· ë™ê²°
-- ì˜ì¡´: policy_level_mix, policy_type_weights, policy_thresholds, users, items,
--       attempts, user_item_status, user_concept_status, sessions, session_items
-- ì£¼ì˜: SECURITY DEFINER + search_path ê³ ì •

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,        -- 'new_only' | 'mix' | 'review_only' | 'weak_focus'
  p_count int default null    -- nullì´ë©´ ì •ì±…ì˜ default_session_size ì‚¬ìš©
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;              -- users.current_level (ì •ìˆ˜ ë ˆë²¨)
  v_level_mix jsonb;                -- {"1":0.8,"2":0.2}
  v_type_weights jsonb;             -- {"review":0.5,"new":0.3,"weak":0.2}

  v_level_attempts int;
  v_effective_type session_type;
  v_underfilled boolean := false;

  -- ëª©í‘œ ìˆ˜ëŸ‰
  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

begin
  -- 0) ì •ì±… ë¡œë“œ
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) ì‚¬ìš©ì í˜„ì¬ ë ˆë²¨ & ë ˆë²¨ ë¯¹ìŠ¤
  select coalesce(u.current_level, 1) into v_current_level
  from users u where u.id = p_user_id;

  select plm.level_weights into v_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_level_mix is null then
    v_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- 2) íƒ€ì…ë³„ ë¹„ìœ¨
  select ptw.weights into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) ë ˆë²¨ë³„ ëˆ„ì  í’€ì´ìˆ˜ (ìŠ¤ëƒ…ìƒ· level ì •ìˆ˜ ê¸°ì¤€)
  select coalesce(count(*),0) into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  -- 4) ì„ê³„ ê°€ë“œ
  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 5) íƒ€ì…ë³„ ëª©í‘œ ìˆ˜ëŸ‰ ì‚°ì¶œ
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor( (v_type_weights->>'review')::numeric * v_count )::int;
    tgt_new    := floor( (v_type_weights->>'new')::numeric    * v_count )::int;
    tgt_weak   := floor( (v_type_weights->>'weak')::numeric   * v_count )::int;
    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1; -- mixì˜ ì”ì—¬ëŠ” review ìš°ì„  ë³´ì¶©
      end if;
    end loop;
  end if;

  -- =========================
  -- í›„ë³´ í’€ ê³„ì‚° â†’ ì„ì‹œí…Œì´ë¸”ì— ìµœì¢… ID ì €ì¥
  -- =========================
  -- (ì„¸ì…˜ì´ ëë‚˜ë©´ ìë™ ë“œë¡­ë˜ë„ë¡ on commit drop)
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_level_mix)
    order by 1
  ),
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select ri.id
    from review_items ri
    join lvl on lvl.lvl = ri.level
    order by ri.is_due desc, ri.due_at asc, ri.created_at desc
    limit tgt_review
  ),
  pick_weak as (
    select wi.id
    from weak_items wi
    join lvl on lvl.lvl = wi.level
    order by wi.wscore desc, wi.maxw desc
    limit tgt_weak
  ),
  pick_new as (
    select ni.id
    from new_items ni
    join lvl on lvl.lvl = ni.level
    order by ni.created_at desc
    limit tgt_new
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    where pd.id is null
      and i.status in ('draft','approved')
    order by i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  ) f;

  -- 6) ì„¸ì…˜ ìƒì„± (ì „ëµ ê¸°ë¡ì— tmp_final_ids ê°œìˆ˜ ì‚¬ìš©)
  insert into public.sessions(user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled',      (select count(*) from tmp_final_ids),
      'level_mix',   v_level_mix
    )
  )
  returning id into v_session_id;

  -- 7) ìŠ¤ëƒ…ìƒ· ë™ê²° (tmp_final_ids ì¬ì‚¬ìš©)
  insert into public.session_items(session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,  -- ì •ìˆ˜ë¡œ ì €ì¥ ë³´ì¦
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;



---

## 2. ë‹µì•ˆ ì œì¶œ

```sql
create or replace function submit_attempt(
  p_session_id uuid,
  p_item_id uuid,
  p_answer_raw text,
  p_latency_ms int
)
returns uuid as $$
declare
  v_attempt_id uuid;
begin
  insert into public.attempts(session_id, item_id, answer_raw, latency_ms)
  values (p_session_id, p_item_id, p_answer_raw, p_latency_ms)
  returning id into v_attempt_id;

  return v_attempt_id;
end;
$$ language plpgsql;
```

---

## 3. ì±„ì  (ë£° ê¸°ë°˜)

create or replace function save_grade(
  p_attempt_id uuid,
  p_label grade_label,
  p_feedback text,
  p_minimal_rewrite text,
  p_error_tags text[] default array[]::text[],
  p_judge judge_type default 'rule',
  p_evidence jsonb default '{}'::jsonb
)
returns void as $$
begin
  insert into public.grades(
    attempt_id,
    label,
    feedback_short,
    minimal_rewrite,
    error_tags,
    judge,
    evidence_json,
    created_at
  )
  values (
    p_attempt_id,
    p_label,
    p_feedback,
    p_minimal_rewrite,
    p_error_tags,
    p_judge,
    p_evidence,
    now()
  )
  on conflict (attempt_id) do update
  set label = excluded.label,
      feedback_short = excluded.feedback_short,
      minimal_rewrite = excluded.minimal_rewrite,
      error_tags = excluded.error_tags,
      judge = excluded.judge,
      evidence_json = excluded.evidence_json,
      created_at = excluded.created_at;
end;
$$ language plpgsql;


---

## 4. ë¼ì´íŠ¸ë„ˆ ê°±ì‹  (SRS)

```sql
create or replace function update_srs(p_session_id uuid)
returns void as $$
declare
  rec record;
  v_next_box int;
  v_interval int;
begin
  for rec in
    select a.item_id, g.label, s.user_id, si.snapshot_json->>'concept_key' as concept_key
    from public.attempts a
    join public.grades g on g.attempt_id = a.id
    join public.sessions s on s.id = a.session_id
    join public.session_items si on si.session_id = a.session_id and si.item_id = a.item_id
    where a.session_id = p_session_id
  loop
    -- ë¼ì´íŠ¸ë„ˆ ë°•ìŠ¤ ê·œì¹™
    if rec.label in ('correct','variant') then
      v_next_box := least(coalesce((select box_level from public.user_item_status
                                    where user_id=rec.user_id and item_id=rec.item_id),0)+1, 5);
    else
      v_next_box := 1;
    end if;

    -- ê°„ê²©í‘œ
    v_interval := case v_next_box
      when 1 then 0
      when 2 then 1
      when 3 then 3
      when 4 then 7
      else 14 end;

    -- user_item_status (ë‹¨ì–´/phrase)
    insert into public.user_item_status(user_id, item_id, box_level, last_attempt_at, next_due_at,
                                        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id)
    values (rec.user_id, rec.item_id, v_next_box, now(), now()+make_interval(days=>v_interval),
            case when rec.label in ('correct','variant') then 1 else 0 end, 1,
            case when rec.label in ('correct','variant') then 1 else 0 end,
            case when rec.label in ('wrong','near_miss') then 1 else 0 end,
            rec.label, p_session_id)
    on conflict (user_id, item_id) do update
      set box_level = excluded.box_level,
          last_attempt_at = excluded.last_attempt_at,
          next_due_at = excluded.next_due_at,
          streak = user_item_status.streak + excluded.streak,
          total_attempts = user_item_status.total_attempts+1,
          correct_count = user_item_status.correct_count + excluded.correct_count,
          wrong_count = user_item_status.wrong_count + excluded.wrong_count,
          last_result = excluded.last_result,
          last_session_id = excluded.last_session_id;

    -- user_concept_status (ë¬¸ì¥ ê°œë…)
    insert into public.user_concept_status(user_id, concept_key, box_level, last_attempt_at, next_due_at,
                                           streak, total_attempts, correct_count, wrong_count, last_result, last_session_id)
    values (rec.user_id, rec.concept_key, v_next_box, now(), now()+make_interval(days=>v_interval),
            case when rec.label in ('correct','variant') then 1 else 0 end, 1,
            case when rec.label in ('correct','variant') then 1 else 0 end,
            case when rec.label in ('wrong','near_miss') then 1 else 0 end,
            rec.label, p_session_id)
    on conflict (user_id, concept_key) do update
      set box_level = excluded.box_level,
          last_attempt_at = excluded.last_attempt_at,
          next_due_at = excluded.next_due_at,
          streak = user_concept_status.streak + excluded.streak,
          total_attempts = user_concept_status.total_attempts+1,
          correct_count = user_concept_status.correct_count + excluded.correct_count,
          wrong_count = user_concept_status.wrong_count + excluded.wrong_count,
          last_result = excluded.last_result,
          last_session_id = excluded.last_session_id;
  end loop;
end;
$$ language plpgsql;
```

---

## 5. ì„¸ì…˜ ì™„ë£Œ

```sql
create or replace function complete_session(p_session_id uuid)
returns void as $$
begin
  update public.sessions
  set status = 'completed',
      ended_at = now()
  where id = p_session_id;
end;
$$ language plpgsql;
```

---
-- íŒŒì¼/ì—­í• : public.get_session_result(uuid)
-- ëª©ì : ì„¸ì…˜ ê²°ê³¼ë¥¼ "ê° ë¬¸í•­ì˜ ë§ˆì§€ë§‰ ì‹œë„ + grade(1:1)" ê¸°ì¤€ìœ¼ë¡œ JSONBë¡œ ë°˜í™˜
-- ì „ì œ: attempts.submitted_at ì¡´ì¬, attempts:grades = 1:1, ì±„ì ì€ snapshot_json ê¸°ì¤€
-- ë³´ì•ˆ: SECURITY DEFINER + ì†Œìœ ì ê°€ë“œ

create or replace function public.get_session_result(p_session_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid;
  v_started_at timestamptz;
  v_ended_at timestamptz;
  v_items jsonb;
  v_total int;
  v_correct int;
begin
  -- 0) ì„¸ì…˜ ë©”íƒ€ + ì†Œìœ ì í™•ì¸
  select s.user_id, s.started_at, s.ended_at
    into v_user_id, v_started_at, v_ended_at
  from public.sessions s
  where s.id = p_session_id;

  if v_user_id is null then
    raise exception 'Session not found';
  end if;

  -- ë¹„-service í† í°ì´ë©´ ë³¸ì¸ë§Œ í—ˆìš©
  if current_setting('request.jwt.claim.sub', true) is not null then
    if v_user_id <> auth.uid() then
      raise exception 'Forbidden';
    end if;
  end if;

  -- 1) ë¬¸í•­ ë°°ì—´(ë§ˆì§€ë§‰ ì‹œë„ + grade 1ê°œ í¬í•¨)
  --    â— í•µì‹¬: ì •ë ¬ì€ jsonb_agg ë‚´ë¶€ì˜ ORDER BYë¡œë§Œ ì²˜ë¦¬ (SELECT ë°”ê¹¥ ORDER BY ê¸ˆì§€)
  v_items := coalesce((
    select jsonb_agg(
      jsonb_build_object(
        'order_index', si.order_index,
        'item_id',     si.item_id,
        'snapshot',    si.snapshot_json,
        'attempt', case when la.id is null then null else jsonb_build_object(
            'attempt_id',      la.id,
            'answer_raw',      la.answer_raw,
            'submitted_at',    la.submitted_at,
            'grade_label',     g.label,
            'feedback_short',  g.feedback_short,
            'minimal_rewrite', g.minimal_rewrite,
            'error_tags',      g.error_tags
        ) end
      )
      ORDER BY si.order_index            -- âœ… ì •ë ¬ì„ ì§‘ê³„ ë‚´ë¶€ë¡œ ì´ë™
    )
    from public.session_items si
    -- ê° ë¬¸í•­ì˜ ë§ˆì§€ë§‰ ì‹œë„(ì œì¶œ ì‹œê°„ ê¸°ì¤€) 1ê°œ
    left join lateral (
      select a.*
      from public.attempts a
      where a.session_id = p_session_id
        and a.item_id    = si.item_id
      order by a.submitted_at desc       -- âœ… created_at â†’ submitted_at
      limit 1
    ) la on true
    left join public.grades g on g.attempt_id = la.id
    where si.session_id = p_session_id
  ), '[]'::jsonb);

  -- 2) ì´ ë¬¸í•­ ìˆ˜
  select count(*) into v_total
  from public.session_items
  where session_id = p_session_id;

  -- 3) ë§ˆì§€ë§‰ ì‹œë„ ê¸°ì¤€ ì •ë‹µ ìˆ˜(correct|variant)
  v_correct := coalesce((
    with last_attempts as (
      select si.item_id, la.id as attempt_id
      from public.session_items si
      join lateral (
        select a.id
        from public.attempts a
        where a.session_id = p_session_id
          and a.item_id    = si.item_id
        order by a.submitted_at desc     -- âœ… ì—¬ê¸°ë„ ë™ì¼
        limit 1
      ) la on true
      where si.session_id = p_session_id
    )
    select count(*)
    from last_attempts l
    join public.grades g on g.attempt_id = l.attempt_id
    where g.label in ('correct','variant')
  ), 0);

  return jsonb_build_object(
    'session_id', p_session_id,
    'started_at', v_started_at,
    'ended_at',   v_ended_at,
    'total',      v_total,
    'correct',    v_correct,
    'items',      v_items
  );
end;
$$;

grant execute on function public.get_session_result(uuid) to authenticated;

---
# ğŸ“Œ ìš”ì•½

* ê° í•¨ìˆ˜ëŠ” **ì‚¬ì–‘ì„œì˜ API ì—”ë“œí¬ì¸íŠ¸ì™€ 1:1 ëŒ€ì‘**
* **ë¼ì´íŠ¸ë„ˆ ë°•ìŠ¤ ê·œì¹™**(ë§ìŒ â†’ ìƒí–¥, í‹€ë¦¼ â†’ ì´ˆê¸°í™”) ë°˜ì˜
* **item vs concept ë¶„ë¦¬**ë„ í¬í•¨

---
