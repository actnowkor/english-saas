# 백엔드 루프 자동화 함수 사양서 (Postgres Functions)

## 0) 원칙

* 모든 함수는 **SQL Editor → Function** 으로 생성.
* 프론트엔드(API)에서는 함수만 호출하면 됨.
* **라이트너 박스 규칙** 반영:

  * Box 1 = 당일, Box 2 = +1일, Box 3 = +3일, Box 4 = +7일, Box 5 = +14일
  * 맞음(correct/variant) → box +1 (최대 5)
  * 틀림(wrong/near\_miss) → box = 1
  * **문장(concept)** 은 `user_concept_status`, **단어/phrase(item)** 는 `user_item_status`

---

## 1. 세션 시작 (출제)

-- 파일/역할: DB 함수 / 출제+세션생성+스냅샷 동결
-- 의존: policy_level_mix, policy_type_weights, policy_thresholds, users, items,
--       attempts, user_item_status, user_concept_status, sessions, session_items
-- 주의: SECURITY DEFINER + search_path 고정

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,        -- 'new_only' | 'mix' | 'review_only' | 'weak_focus'
  p_count int default null    -- null이면 정책의 default_session_size 사용
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;              -- users.current_level (정수 레벨)
  v_level_mix jsonb;                -- {"1":0.8,"2":0.2}
  v_type_weights jsonb;             -- {"review":0.5,"new":0.3,"weak":0.2}

  v_level_attempts int;
  v_effective_type session_type;
  v_underfilled boolean := false;

  -- 목표 수량
  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

begin
  -- 0) 정책 로드
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) 사용자 현재 레벨 & 레벨 믹스
  select coalesce(u.current_level, 1) into v_current_level
  from users u where u.id = p_user_id;

  select plm.level_weights into v_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_level_mix is null then
    v_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- 2) 타입별 비율
  select ptw.weights into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) 레벨별 누적 풀이수 (스냅샷 level 정수 기준)
  select coalesce(count(*),0) into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  -- 4) 임계 가드
  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 5) 타입별 목표 수량 산출
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor( (v_type_weights->>'review')::numeric * v_count )::int;
    tgt_new    := floor( (v_type_weights->>'new')::numeric    * v_count )::int;
    tgt_weak   := floor( (v_type_weights->>'weak')::numeric   * v_count )::int;
    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1; -- mix의 잔여는 review 우선 보충
      end if;
    end loop;
  end if;

  -- =========================
  -- 후보 풀 계산 → 임시테이블에 최종 ID 저장
  -- =========================
  -- (세션이 끝나면 자동 드롭되도록 on commit drop)
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_level_mix)
    order by 1
  ),
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select ri.id
    from review_items ri
    join lvl on lvl.lvl = ri.level
    order by ri.is_due desc, ri.due_at asc, ri.created_at desc
    limit tgt_review
  ),
  pick_weak as (
    select wi.id
    from weak_items wi
    join lvl on lvl.lvl = wi.level
    order by wi.wscore desc, wi.maxw desc
    limit tgt_weak
  ),
  pick_new as (
    select ni.id
    from new_items ni
    join lvl on lvl.lvl = ni.level
    order by ni.created_at desc
    limit tgt_new
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    where pd.id is null
      and i.status in ('draft','approved')
    order by i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  ) f;

  -- 6) 세션 생성 (전략 기록에 tmp_final_ids 개수 사용)
  insert into public.sessions(user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled',      (select count(*) from tmp_final_ids),
      'level_mix',   v_level_mix
    )
  )
  returning id into v_session_id;

  -- 7) 스냅샷 동결 (tmp_final_ids 재사용)
  insert into public.session_items(session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,  -- 정수로 저장 보증
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;



---

## 2. 답안 제출

```sql
create or replace function submit_attempt(
  p_session_id uuid,
  p_item_id uuid,
  p_answer_raw text,
  p_latency_ms int
)
returns uuid as $$
declare
  v_attempt_id uuid;
begin
  insert into public.attempts(session_id, item_id, answer_raw, latency_ms)
  values (p_session_id, p_item_id, p_answer_raw, p_latency_ms)
  returning id into v_attempt_id;

  return v_attempt_id;
end;
$$ language plpgsql;
```

---

## 3. 채점 (룰 기반)

create or replace function save_grade(
  p_attempt_id uuid,
  p_label grade_label,
  p_feedback text,
  p_minimal_rewrite text,
  p_error_tags text[] default array[]::text[],
  p_judge judge_type default 'rule',
  p_evidence jsonb default '{}'::jsonb
)
returns void as $$
begin
  insert into public.grades(
    attempt_id,
    label,
    feedback_short,
    minimal_rewrite,
    error_tags,
    judge,
    evidence_json,
    created_at
  )
  values (
    p_attempt_id,
    p_label,
    p_feedback,
    p_minimal_rewrite,
    p_error_tags,
    p_judge,
    p_evidence,
    now()
  )
  on conflict (attempt_id) do update
  set label = excluded.label,
      feedback_short = excluded.feedback_short,
      minimal_rewrite = excluded.minimal_rewrite,
      error_tags = excluded.error_tags,
      judge = excluded.judge,
      evidence_json = excluded.evidence_json,
      created_at = excluded.created_at;
end;
$$ language plpgsql;


---

## 4. 라이트너 갱신 (SRS)

```sql
create or replace function update_srs(p_session_id uuid)
returns void as $$
declare
  rec record;
  v_next_box int;
  v_interval int;
begin
  for rec in
    select a.item_id, g.label, s.user_id, si.snapshot_json->>'concept_key' as concept_key
    from public.attempts a
    join public.grades g on g.attempt_id = a.id
    join public.sessions s on s.id = a.session_id
    join public.session_items si on si.session_id = a.session_id and si.item_id = a.item_id
    where a.session_id = p_session_id
  loop
    -- 라이트너 박스 규칙
    if rec.label in ('correct','variant') then
      v_next_box := least(coalesce((select box_level from public.user_item_status
                                    where user_id=rec.user_id and item_id=rec.item_id),0)+1, 5);
    else
      v_next_box := 1;
    end if;

    -- 간격표
    v_interval := case v_next_box
      when 1 then 0
      when 2 then 1
      when 3 then 3
      when 4 then 7
      else 14 end;

    -- user_item_status (단어/phrase)
    insert into public.user_item_status(user_id, item_id, box_level, last_attempt_at, next_due_at,
                                        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id)
    values (rec.user_id, rec.item_id, v_next_box, now(), now()+make_interval(days=>v_interval),
            case when rec.label in ('correct','variant') then 1 else 0 end, 1,
            case when rec.label in ('correct','variant') then 1 else 0 end,
            case when rec.label in ('wrong','near_miss') then 1 else 0 end,
            rec.label, p_session_id)
    on conflict (user_id, item_id) do update
      set box_level = excluded.box_level,
          last_attempt_at = excluded.last_attempt_at,
          next_due_at = excluded.next_due_at,
          streak = user_item_status.streak + excluded.streak,
          total_attempts = user_item_status.total_attempts+1,
          correct_count = user_item_status.correct_count + excluded.correct_count,
          wrong_count = user_item_status.wrong_count + excluded.wrong_count,
          last_result = excluded.last_result,
          last_session_id = excluded.last_session_id;

    -- user_concept_status (문장 개념)
    insert into public.user_concept_status(user_id, concept_key, box_level, last_attempt_at, next_due_at,
                                           streak, total_attempts, correct_count, wrong_count, last_result, last_session_id)
    values (rec.user_id, rec.concept_key, v_next_box, now(), now()+make_interval(days=>v_interval),
            case when rec.label in ('correct','variant') then 1 else 0 end, 1,
            case when rec.label in ('correct','variant') then 1 else 0 end,
            case when rec.label in ('wrong','near_miss') then 1 else 0 end,
            rec.label, p_session_id)
    on conflict (user_id, concept_key) do update
      set box_level = excluded.box_level,
          last_attempt_at = excluded.last_attempt_at,
          next_due_at = excluded.next_due_at,
          streak = user_concept_status.streak + excluded.streak,
          total_attempts = user_concept_status.total_attempts+1,
          correct_count = user_concept_status.correct_count + excluded.correct_count,
          wrong_count = user_concept_status.wrong_count + excluded.wrong_count,
          last_result = excluded.last_result,
          last_session_id = excluded.last_session_id;
  end loop;
end;
$$ language plpgsql;
```

---

## 5. 세션 완료

```sql
create or replace function complete_session(p_session_id uuid)
returns void as $$
begin
  update public.sessions
  set status = 'completed',
      ended_at = now()
  where id = p_session_id;
end;
$$ language plpgsql;
```

---
-- 파일/역할: public.get_session_result(uuid)
-- 목적: 세션 결과를 "각 문항의 마지막 시도 + grade(1:1)" 기준으로 JSONB로 반환
-- 전제: attempts.submitted_at 존재, attempts:grades = 1:1, 채점은 snapshot_json 기준
-- 보안: SECURITY DEFINER + 소유자 가드

create or replace function public.get_session_result(p_session_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid;
  v_started_at timestamptz;
  v_ended_at timestamptz;
  v_items jsonb;
  v_total int;
  v_correct int;
begin
  -- 0) 세션 메타 + 소유자 확인
  select s.user_id, s.started_at, s.ended_at
    into v_user_id, v_started_at, v_ended_at
  from public.sessions s
  where s.id = p_session_id;

  if v_user_id is null then
    raise exception 'Session not found';
  end if;

  -- 비-service 토큰이면 본인만 허용
  if current_setting('request.jwt.claim.sub', true) is not null then
    if v_user_id <> auth.uid() then
      raise exception 'Forbidden';
    end if;
  end if;

  -- 1) 문항 배열(마지막 시도 + grade 1개 포함)
  --    ❗ 핵심: 정렬은 jsonb_agg 내부의 ORDER BY로만 처리 (SELECT 바깥 ORDER BY 금지)
  v_items := coalesce((
    select jsonb_agg(
      jsonb_build_object(
        'order_index', si.order_index,
        'item_id',     si.item_id,
        'snapshot',    si.snapshot_json,
        'attempt', case when la.id is null then null else jsonb_build_object(
            'attempt_id',      la.id,
            'answer_raw',      la.answer_raw,
            'submitted_at',    la.submitted_at,
            'grade_label',     g.label,
            'feedback_short',  g.feedback_short,
            'minimal_rewrite', g.minimal_rewrite,
            'error_tags',      g.error_tags
        ) end
      )
      ORDER BY si.order_index            -- ✅ 정렬을 집계 내부로 이동
    )
    from public.session_items si
    -- 각 문항의 마지막 시도(제출 시간 기준) 1개
    left join lateral (
      select a.*
      from public.attempts a
      where a.session_id = p_session_id
        and a.item_id    = si.item_id
      order by a.submitted_at desc       -- ✅ created_at → submitted_at
      limit 1
    ) la on true
    left join public.grades g on g.attempt_id = la.id
    where si.session_id = p_session_id
  ), '[]'::jsonb);

  -- 2) 총 문항 수
  select count(*) into v_total
  from public.session_items
  where session_id = p_session_id;

  -- 3) 마지막 시도 기준 정답 수(correct|variant)
  v_correct := coalesce((
    with last_attempts as (
      select si.item_id, la.id as attempt_id
      from public.session_items si
      join lateral (
        select a.id
        from public.attempts a
        where a.session_id = p_session_id
          and a.item_id    = si.item_id
        order by a.submitted_at desc     -- ✅ 여기도 동일
        limit 1
      ) la on true
      where si.session_id = p_session_id
    )
    select count(*)
    from last_attempts l
    join public.grades g on g.attempt_id = l.attempt_id
    where g.label in ('correct','variant')
  ), 0);

  return jsonb_build_object(
    'session_id', p_session_id,
    'started_at', v_started_at,
    'ended_at',   v_ended_at,
    'total',      v_total,
    'correct',    v_correct,
    'items',      v_items
  );
end;
$$;

grant execute on function public.get_session_result(uuid) to authenticated;

---
# 📌 요약

* 각 함수는 **사양서의 API 엔드포인트와 1:1 대응**
* **라이트너 박스 규칙**(맞음 → 상향, 틀림 → 초기화) 반영
* **item vs concept 분리**도 포함

---
