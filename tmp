create or replace function public.get_session_result(p_session_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();            -- ?„ì¬ ë¡œê·¸?¸í•œ ?¬ìš©??
  _own boolean;                       -- ?¸ì…˜ ?Œìœ  ?¬ë?
  _result jsonb;                      -- ìµœì¢… ë°˜í™˜ JSON
begin
  select exists (
    select 1
    from public.sessions s
    where s.id = p_session_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  with si as (
    select id, session_id, item_id, order_index, snapshot_json
    from public.session_items
    where session_id = p_session_id
  ),
  la_graded as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    join public.grades g on g.attempt_id = a.id
    where a.session_id = p_session_id
    order by a.item_id, g.created_at desc nulls last, a.submitted_at desc nulls last, a.id desc
  ),
  la_all as (
    select distinct on (a.item_id)
      a.item_id,
      a.id as attempt_id,
      a.answer_raw,
      a.submitted_at,
      a.latency_ms
    from public.attempts a
    where a.session_id = p_session_id
    order by a.item_id, a.submitted_at desc nulls last, a.id desc
  ),
  la as (
    select
      coalesce(g.item_id, a.item_id) as item_id,
      coalesce(g.attempt_id, a.attempt_id) as attempt_id,
      coalesce(g.answer_raw, a.answer_raw) as answer_raw,
      coalesce(g.submitted_at, a.submitted_at) as submitted_at,
      coalesce(g.latency_ms, a.latency_ms) as latency_ms
    from la_all a
    left join la_graded g on g.item_id = a.item_id
  ),
  gr as (
    select attempt_id, label, feedback_short, minimal_rewrite, error_tags
    from public.grades
  ),
  ck as (                             -- ?¸ì…˜ ???±ì¥??concept_key ëª©ë¡
    select distinct si.snapshot_json->>'concept_key' as concept_key
    from si
    where si.snapshot_json ? 'concept_key'
  ),
  cm as (                             -- ê°œë…?’í•œê¸€ëª?ë§¤í•‘
    select c.concept_key, c.display_name, coalesce(c.description, '') as description
    from public.concepts c
    join ck on ck.concept_key = c.concept_key
  ),
  meta as (
    select s.started_at, s.ended_at
    from public.sessions s
    where s.id = p_session_id
  )
  select jsonb_build_object(
    'session_id', p_session_id,
    'started_at', to_char((select started_at from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'ended_at',   to_char((select ended_at   from meta), 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
    'total',      (select count(*) from si),                          -- ??count(*) ë¡?êµì²´
    'correct',    coalesce((
                     select count(*)
                     from la
                     join gr on gr.attempt_id = la.attempt_id
                     where gr.label in ('correct','variant')
                   ), 0),
    'items',      coalesce((
                     select jsonb_agg(
                       jsonb_build_object(
                         'order_index',    si.order_index,
                         'item_id',        si.item_id,
                         'question',       si.snapshot_json->>'source_ko',
                         'correct_answer', si.snapshot_json->>'answer_en',
                         'concept_key',    si.snapshot_json->>'concept_key',
                         'concept_ko',     (
                                            select cm.display_name
                                            from cm
                                            where cm.concept_key = si.snapshot_json->>'concept_key'
                                            limit 1
                                          ),
                         'attempt_id',     la.attempt_id,
                         'submitted_at',   to_char(la.submitted_at, 'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
                         'latency_ms',     la.latency_ms,
                         'user_answer',    la.answer_raw,
                         'label',          gr.label,
                         'feedback',       gr.feedback_short,
                         'minimal_rewrite',gr.minimal_rewrite
                       )
                       order by si.order_index
                     )
                     from si
                     left join la on la.item_id = si.item_id
                     left join gr on gr.attempt_id = la.attempt_id
                   ), '[]'::jsonb)
  )
  into _result;

  return _result;
end;
$$;

----------------------
create or replace function public.save_grade(
  p_attempt_id uuid,
  p_label grade_label,
  p_feedback text,
  p_minimal_rewrite text,
  p_error_tags text[] default array[]::text[],
  p_judge judge_type default 'rule',
  p_evidence jsonb default '{}'::jsonb
)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  _uid uuid := auth.uid();
  _own boolean;
begin
  -- 0) ?Œìœ ê¶?ê²€ì¦? ?´ë‹¹ attemptê°€ ?„ì¬ ?¬ìš©???Œìœ  ?¸ì…˜?¸ì? ?•ì¸
  select exists (
    select 1
    from public.attempts a
    join public.sessions s on s.id = a.session_id
    where a.id = p_attempt_id
      and s.user_id = _uid
  ) into _own;

  if not _own then
    raise exception 'FORBIDDEN' using errcode = '42501';
  end if;

  -- 1) upsert: created_at?€ ìµœì´ˆ ?½ì…ë§? ?…ë°?´íŠ¸ ?œì—??ë³´ì¡´
  insert into public.grades (
    attempt_id,
    label,
    feedback_short,
    minimal_rewrite,
    error_tags,
    judge,
    evidence_json,
    created_at
  )
  values (
    p_attempt_id,
    p_label,
    p_feedback,
    p_minimal_rewrite,
    p_error_tags,
    p_judge,
    p_evidence,
    now()
  )
  on conflict (attempt_id) do update
  set label           = excluded.label,
      feedback_short  = excluded.feedback_short,
      minimal_rewrite = excluded.minimal_rewrite,
      error_tags      = excluded.error_tags,
      judge           = excluded.judge,
      evidence_json   = excluded.evidence_json
  ;
end;
$$;

grant execute on function public.save_grade(
  uuid, grade_label, text, text, text[], judge_type, jsonb
) to authenticated;
------------------------
create or replace function complete_session(p_session_id uuid)
returns void as $$
begin
  update public.sessions
  set status = 'completed',
      ended_at = now()
  where id = p_session_id;
end;
$$ language plpgsql;

------------------------


/*
ëª©ì 

?¸ì…˜ ??ì±„ì  ê²°ê³¼(grade)ë¥?ë°”íƒ•?¼ë¡œ ?¼ì´?¸ë„ˆ ë°•ìŠ¤ë¥?ê°±ì‹ 
?¨ì–´/êµ?word/phrase) ??user_item_status
ë¬¸ì¥(sentence) ??user_concept_status
ê°™ì? ë¬¸í•­???¤ì¤‘ ?œë„ê°€ ?ˆì„ ê²½ìš° "ë§ˆì?ë§?ê°€??ìµœê·¼) ì±„ì ???œë„"ë§?ë°˜ì˜
?€???ì • ê·œì¹™

session_items.snapshot_json->>'type' (?Œë¬¸??
items.type::text (?Œë¬¸??
concept_key ? ë¬´ë¡?ì¶”ì • (?ˆìœ¼ë©?sentence, ?†ìœ¼ë©?word)
ê°„ê²©????
box 1: 0d, 2: 1d, 3: 3d, 4: 7d, 5: 14d

?„ì œ

user_item_status(user_id, item_id) unique

user_concept_status(user_id, concept_key) unique

attempts:grades = 1:1?´ë©°, grades.label ??('correct','variant','near_miss','wrong')

ë³??¨ìˆ˜??SECURITY DEFINER?´ë©°, ?´ë??ì„œ ?„ìš”???Œì´ë¸”ì— ?€??RLS ?ˆìš© ?ëŠ” ?°íšŒë¥?ë³´ì¥?´ì•¼ ??
*/

create or replace function public.update_srs(p_session_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  rec record;
  v_is_correct boolean;

  -- item(word/phrase)??
  v_prev_item int;
  v_next_box_item int;
  v_interval_item int;

  -- concept(sentence)??
  v_prev_concept int;
  v_next_box_concept int;
  v_interval_concept int;

  v_item_type text;
begin
  -- ê°?ë¬¸í•­(item)ë³?ê°€??ìµœê·¼ 1ê°?attempt(ì±„ì  ?„ë£Œ??ê²ƒë§Œ)ë§?? ë³„
  for rec in
    with last_per_item as (
      select distinct on (a.item_id)
             a.id as attempt_id
      from public.attempts a
      join public.grades g
        on g.attempt_id = a.id
      where a.session_id = p_session_id
      order by a.item_id,
               g.created_at desc nulls last,
               a.submitted_at desc nulls last,
               a.id desc
    )
    select a.item_id,
           g.label,
           s.user_id,
           si.snapshot_json->>'concept_key' as concept_key
    from last_per_item l
    join public.attempts a on a.id = l.attempt_id
    join public.grades   g on g.attempt_id = a.id
    join public.sessions s on s.id = a.session_id
    join public.session_items si
      on si.session_id = a.session_id
     and si.item_id    = a.item_id
  loop
    v_is_correct := (rec.label in ('correct','variant'));

    -- item ?€??êµ¬ë¶„: concept_key ì¡´ì¬ ??sentence, ?„ë‹ˆë©?word/phrase
    if rec.concept_key is not null then
      v_item_type := 'sentence';
    else
      v_item_type := 'word';
    end if;

    -- 1) ?¨ì–´/êµ?phrase/word): user_item_status ?…ë°?´íŠ¸
    if v_item_type in ('word','phrase') then
      select box_level into v_prev_item
      from public.user_item_status
      where user_id = rec.user_id
        and item_id = rec.item_id;

      if v_is_correct then
        v_next_box_item := least(coalesce(v_prev_item, 0) + 1, 5);
      else
        v_next_box_item := 1;
      end if;

      v_interval_item := case v_next_box_item
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_item_status(
        user_id, item_id, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.item_id, v_next_box_item, now(), now() + make_interval(days => v_interval_item),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, item_id) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_item_status.streak         + excluded.streak,
            total_attempts  = public.user_item_status.total_attempts + 1,
            correct_count   = public.user_item_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_item_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;

    -- 2) ë¬¸ì¥(sentence): user_concept_status ?…ë°?´íŠ¸
    if v_item_type = 'sentence' and rec.concept_key is not null then
      select box_level into v_prev_concept
      from public.user_concept_status
      where user_id = rec.user_id
        and concept_key = rec.concept_key;

      if v_is_correct then
        v_next_box_concept := least(coalesce(v_prev_concept, 0) + 1, 5);
      else
        v_next_box_concept := 1;
      end if;

      v_interval_concept := case v_next_box_concept
        when 1 then 0
        when 2 then 1
        when 3 then 3
        when 4 then 7
        else 14 end;

      insert into public.user_concept_status(
        user_id, concept_key, box_level, last_attempt_at, next_due_at,
        streak, total_attempts, correct_count, wrong_count, last_result, last_session_id
      )
      values (
        rec.user_id, rec.concept_key, v_next_box_concept, now(), now() + make_interval(days => v_interval_concept),
        case when v_is_correct then 1 else 0 end, 1,
        case when v_is_correct then 1 else 0 end,
        case when not v_is_correct then 1 else 0 end,
        rec.label, p_session_id
      )
      on conflict (user_id, concept_key) do update
        set box_level       = excluded.box_level,
            last_attempt_at = excluded.last_attempt_at,
            next_due_at     = excluded.next_due_at,
            streak          = public.user_concept_status.streak         + excluded.streak,
            total_attempts  = public.user_concept_status.total_attempts + 1,
            correct_count   = public.user_concept_status.correct_count  + excluded.correct_count,
            wrong_count     = public.user_concept_status.wrong_count    + excluded.wrong_count,
            last_result     = excluded.last_result,
            last_session_id = excluded.last_session_id;
    end if;
  end loop;

  return;
end;
$$;


---------------------------
create or replace function submit_attempt(
  p_session_id uuid,
  p_item_id uuid,
  p_answer_raw text,
  p_latency_ms int
)
returns uuid as $$
declare
  v_attempt_id uuid;
begin
  insert into public.attempts(session_id, item_id, answer_raw, latency_ms)
  values (p_session_id, p_item_id, p_answer_raw, p_latency_ms)
  returning id into v_attempt_id;

  return v_attempt_id;
end;
$$ language plpgsql;

-----------------------------
-- ?Œì¼/??• : DB ?¨ìˆ˜ / ì¶œì œ+?¸ì…˜?ì„±+?¤ëƒ…???™ê²°
-- ?˜ì¡´: policy_level_mix, policy_type_weights, policy_thresholds, users, items,
--       attempts, user_item_status, user_concept_status, sessions, session_items
-- ì£¼ì˜: SECURITY DEFINER + search_path ê³ ì •

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,        -- 'new_only' | 'mix' | 'review_only' | 'weak_focus'
  p_count int default null    -- null?´ë©´ ?•ì±…??default_session_size ?¬ìš©
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;              -- users.current_level (?•ìˆ˜ ?ˆë²¨)
  v_level_mix jsonb;                -- {"1":0.8,"2":0.2}
  v_type_weights jsonb;             -- {"review":0.5,"new":0.3,"weak":0.2}

  v_level_attempts int;
  v_effective_type session_type;
  v_underfilled boolean := false;

  -- ëª©í‘œ ?˜ëŸ‰
  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

begin
  -- 0) ?•ì±… ë¡œë“œ
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  -- 1) ?¬ìš©???„ì¬ ?ˆë²¨ & ?ˆë²¨ ë¯¹ìŠ¤
  select coalesce(u.current_level, 1) into v_current_level
  from users u where u.id = p_user_id;

  select plm.level_weights into v_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_level_mix is null then
    v_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  -- 2) ?€?…ë³„ ë¹„ìœ¨
  select ptw.weights into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  -- 3) ?ˆë²¨ë³??„ì  ?€?´ìˆ˜ (?¤ëƒ…??level ?•ìˆ˜ ê¸°ì?)
  select coalesce(count(*),0) into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  -- 4) ?„ê³„ ê°€??
  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  -- 5) ?€?…ë³„ ëª©í‘œ ?˜ëŸ‰ ?°ì¶œ
  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor( (v_type_weights->>'review')::numeric * v_count )::int;
    tgt_new    := floor( (v_type_weights->>'new')::numeric    * v_count )::int;
    tgt_weak   := floor( (v_type_weights->>'weak')::numeric   * v_count )::int;
    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1; -- mix???”ì—¬??review ?°ì„  ë³´ì¶©
      end if;
    end loop;
  end if;

  -- =========================
  -- ?„ë³´ ?€ ê³„ì‚° ???„ì‹œ?Œì´ë¸”ì— ìµœì¢… ID ?€??
  -- =========================
  -- (?¸ì…˜???ë‚˜ë©??ë™ ?œë¡­?˜ë„ë¡?on commit drop)
  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_level_mix)
    order by 1
  ),
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select ri.id
    from review_items ri
    join lvl on lvl.lvl = ri.level
    order by ri.is_due desc, ri.due_at asc, ri.created_at desc
    limit tgt_review
  ),
  pick_weak as (
    select wi.id
    from weak_items wi
    join lvl on lvl.lvl = wi.level
    order by wi.wscore desc, wi.maxw desc
    limit tgt_weak
  ),
  pick_new as (
    select ni.id
    from new_items ni
    join lvl on lvl.lvl = ni.level
    order by ni.created_at desc
    limit tgt_new
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    where pd.id is null
      and i.status in ('draft','approved')
    order by i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  ) f;

  -- 6) ?¸ì…˜ ?ì„± (?„ëµ ê¸°ë¡??tmp_final_ids ê°œìˆ˜ ?¬ìš©)
  insert into public.sessions(user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled',      (select count(*) from tmp_final_ids),
      'level_mix',   v_level_mix
    )
  )
  returning id into v_session_id;

  -- 7) ?¤ëƒ…???™ê²° (tmp_final_ids ?¬ì‚¬??
  insert into public.session_items(session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,  -- ?•ìˆ˜ë¡??€??ë³´ì¦
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;
----------------------------------
create or replace function public.get_concepts_ko(p_keys text[])
returns table (concept_key text, display_name text, description text)
language sql
security definer
set search_path = public
as $$
with src as (
select concept_key, display_name, coalesce(description, '') as description
from public.concepts
where concept_key = any(p_keys)
)
select concept_key, display_name, description from src;
$$;

grant execute on function public.get_concepts_ko(text[]) to authenticated;
-------------------------
-- ê²½ë¡œ: supabase/migrations/20250916_level_functions.sql
-- ??• : ?ˆë²¨ ?µê³„Â·?ì •Â·?¸ì…˜ ?ì„± ?¨ìˆ˜ ?•ì˜
-- ?˜ì¡´ê´€ê³? users, sessions, attempts, grades, user_concept_status, items, policy_level_* ?Œì´ë¸? policy_thresholds, policy_type_weights
-- ?¬í•¨ ?¨ìˆ˜: normalize_level_mix, get_user_level_stats, get_difficulty_adjustment, evaluate_user_level_progress, auto_level_up, start_session_custom

set check_function_bodies = on;

create or replace function normalize_level_mix(p_mix jsonb)
returns jsonb
language plpgsql
immutable
as $$
declare
  v_total numeric := 0;
  v_result jsonb := '{}'::jsonb;
  v_key text;
  v_val numeric;
begin
  if p_mix is null then
    return '{}'::jsonb;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_total := v_total + v_val;
    end if;
  end loop;

  if v_total <= 0 then
    return p_mix;
  end if;

  for v_key, v_val in
    select key, (value)::numeric
    from jsonb_each(p_mix)
  loop
    if v_val > 0 then
      v_result := v_result || jsonb_build_object(v_key, round((v_val / v_total)::numeric, 4));
    end if;
  end loop;

  return v_result;
end;
$$;
-- normalize_level_mix: ?ˆë²¨ ë¶„í¬ JSON ?©ê³„ 1.0 ?•ê·œ??

create or replace function get_user_level_stats(p_user_id uuid)
returns table (
  recent_session_id uuid,
  recent_session_started_at timestamptz,
  recent_session_ended_at timestamptz,
  recent_attempts int,
  recent_correct_attempts int,
  recent_correct_rate numeric,
  total_attempts bigint,
  stable_concept_count bigint,
  stable_concept_ratio numeric,
  low_box_concept_count bigint
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_total_concepts bigint;
begin
  select s.id, s.started_at, s.ended_at
  into recent_session_id, recent_session_started_at, recent_session_ended_at
  from sessions s
  where s.user_id = p_user_id
    and s.status = 'completed'
  order by coalesce(s.ended_at, s.started_at) desc
  limit 1;

  if recent_session_id is not null then
    select count(*)::int
    into recent_attempts
    from attempts a
    where a.session_id = recent_session_id;

    select count(*)::int
    into recent_correct_attempts
    from attempts a
    join grades g on g.attempt_id = a.id
    where a.session_id = recent_session_id
      and g.label in ('correct', 'variant');

    recent_correct_rate :=
      case when recent_attempts > 0
           then round((recent_correct_attempts::numeric / recent_attempts)::numeric, 4)
           else 0 end;
  else
    recent_attempts := 0;
    recent_correct_attempts := 0;
    recent_correct_rate := 0;
  end if;

  select coalesce(sum(ucs.total_attempts), 0)
  into total_attempts
  from user_concept_status ucs
  where ucs.user_id = p_user_id;

  select coalesce(count(*), 0)
  into stable_concept_count
  from user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level >= 4;

  select coalesce(count(*), 0)
  into v_total_concepts
  from user_concept_status ucs
  where ucs.user_id = p_user_id;

  stable_concept_ratio :=
    case when v_total_concepts > 0
         then round((stable_concept_count::numeric / v_total_concepts)::numeric, 4)
         else 0 end;

  select coalesce(count(*), 0)
  into low_box_concept_count
  from user_concept_status ucs
  where ucs.user_id = p_user_id
    and ucs.box_level <= 2;

  return next;
end;
$$;

-- get_user_level_stats: ìµœê·¼ ?¸ì…˜Â·ê°œë… ì§‘ê³„ ë°˜í™˜


create or replace function get_difficulty_adjustment(p_user_id uuid)
returns table (
  applied boolean,
  reason text,
  policy_level int,
  recent_correct_rate numeric,
  low_box_concept_count bigint,
  adjusted_mix jsonb
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_level int;
  v_condition jsonb;
  v_threshold_rate numeric;
  v_threshold_low int;
begin
  select current_level
  into v_level
  from users
  where id = p_user_id;

  if v_level is null then
    applied := false;
    reason := '?¬ìš©???ˆë²¨ ?•ë³´ ?†ìŒ';
    policy_level := null;
    recent_correct_rate := 0;
    low_box_concept_count := 0;
    adjusted_mix := null;
    return next;
  end if;

  policy_level := v_level;

  -- ìµœê·¼ ?•ë‹µë¥?
  with recent_sessions as (
    select s.id
    from sessions s
    where s.user_id = p_user_id
      and s.status = 'completed'
    order by coalesce(s.ended_at, s.started_at) desc
    limit 3
  ),
  recent_attempts as (
    select a.id
    from attempts a
    where a.session_id in (select id from recent_sessions)
  ),
  recent_labels as (
    select g.label
    from grades g
    join recent_attempts a on a.id = g.attempt_id
  )
  select case
           when count(*) > 0 then round((count(*) filter (where label in ('correct','variant'))::numeric / count(*))::numeric, 4)
           else 0
         end
  into recent_correct_rate
  from recent_labels;

  -- ??? ë°•ìŠ¤ ê°œìˆ˜
  select coalesce(gs.low_box_concept_count, 0)
  into low_box_concept_count
  from get_user_level_stats(p_user_id) as gs;

  select condition_json, adjusted_mix_json
  into v_condition, adjusted_mix
  from policy_level_adjustments
  where level = v_level;

  if v_condition is null or adjusted_mix is null then
    applied := false;
    reason := 'ì¡°ì • ?•ì±… ?†ìŒ';
    adjusted_mix := null;
    return next;
  end if;

  v_threshold_rate := coalesce((v_condition->>'recent_correct_rate_below')::numeric, 0.6);
  v_threshold_low := coalesce((v_condition->>'low_box_concepts_over')::int, 5);

  if recent_correct_rate < v_threshold_rate
     and low_box_concept_count >= v_threshold_low then
    applied := true;
    reason := format('ìµœê·¼ ?•ë‹µë¥?%.2f < ?•ì±… %.2f, ??? ë°•ìŠ¤ %s ??%s',
                     recent_correct_rate, v_threshold_rate,
                     low_box_concept_count, v_threshold_low);
    adjusted_mix := normalize_level_mix(adjusted_mix);
  else
    applied := false;
    reason := 'ì¡°ê±´ ë¯¸ì¶©ì¡?;
    adjusted_mix := null;
  end if;

  return next;
end;
$$;


-- get_difficulty_adjustment: ìµœê·¼ ?±ê³¼ ê¸°ë°˜ ?œì´??ì¡°ì • ?ì •

create or replace function evaluate_user_level_progress(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_current int;
  v_target int;
  v_policy policy_level_up%rowtype;
  v_stats record;
  v_pass boolean := false;
  v_reason text := '';
begin
  select current_level
  into v_current
  from users
  where id = p_user_id;

  if v_current is null then
    return jsonb_build_object(
      'eligible', false,
      'reason', '?ˆë²¨ ?•ë³´ ?†ìŒ'
    );
  end if;

  v_target := v_current + 1;

  select * into v_policy
  from policy_level_up
  where level = v_target;

  if not found then
    return jsonb_build_object(
      'eligible', false,
      'reason', '?¤ìŒ ?ˆë²¨ ?•ì±… ë¯¸ì •??,
      'current_level', v_current,
      'target_level', v_target
    );
  end if;

  select * into v_stats
  from get_user_level_stats(p_user_id);

  if coalesce(v_stats.total_attempts, 0) < v_policy.min_total_attempts then
    v_reason := format('?„ì  ?œë„??%s < %s',
                       coalesce(v_stats.total_attempts, 0),
                       v_policy.min_total_attempts);
  elsif coalesce(v_stats.recent_correct_rate, 0) < v_policy.min_correct_rate then
    v_reason := format('ìµœê·¼ ?•ë‹µë¥?%.2f < %.2f',
                       coalesce(v_stats.recent_correct_rate, 0),
                       v_policy.min_correct_rate);
  elsif coalesce(v_stats.stable_concept_ratio, 0) < v_policy.min_box_level_ratio then
    v_reason := format('?ˆì • ë¹„ìœ¨ %.2f < %.2f',
                       coalesce(v_stats.stable_concept_ratio, 0),
                       v_policy.min_box_level_ratio);
  else
    v_pass := true;
    v_reason := '?•ì±… ì¶©ì¡±';
  end if;

  return jsonb_build_object(
    'eligible', v_pass,
    'reason', v_reason,
    'current_level', v_current,
    'target_level', v_target,
    'stats', to_jsonb(v_stats)
  );
end;
$$;
-- evaluate_user_level_progress: ?¹ê¸‰ ê°€???¬ë? ?ì •

create or replace function auto_level_up(p_user_id uuid, p_source text default 'auto_assessment')
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_eval jsonb;
  v_eligible boolean;
  v_target int;
  v_new_level int;
begin
  v_eval := evaluate_user_level_progress(p_user_id);
  v_eligible := coalesce((v_eval->>'eligible')::boolean, false);
  v_target := (v_eval->>'target_level')::int;

  if not v_eligible then
    return jsonb_build_object(
      'leveled_up', false,
      'reason', v_eval->>'reason',
      'current_level', v_eval->>'current_level'
    );
  end if;

  update users
  set current_level = v_target
  where id = p_user_id
  returning current_level
  into v_new_level;

  insert into user_level_history (user_id, level, source)
  values (p_user_id, v_new_level, coalesce(p_source, 'auto_assessment'));

  return jsonb_build_object(
    'leveled_up', true,
    'new_level', v_new_level,
    'source', coalesce(p_source, 'auto_assessment')
  );
end;
$$;
-- auto_level_up: ?¹ê¸‰ ì²˜ë¦¬ ë°??´ë ¥ ê¸°ë¡

create or replace function public.start_session_custom(
  p_user_id uuid,
  p_type session_type,
  p_count int default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_session_id uuid;
  v_default_count int;
  v_count int;
  v_force_new boolean;
  v_min_attempts int;
  v_review_due_first boolean;
  v_weak_requires_history boolean;

  v_current_level int;
  v_base_level_mix jsonb;
  v_applied_level_mix jsonb;
  v_type_weights jsonb;

  v_level_attempts int;
  v_effective_type session_type;
  v_underfilled boolean := false;

  tgt_review int := 0;
  tgt_new    int := 0;
  tgt_weak   int := 0;

  v_adjust record;
  v_stats record;
begin
  select default_session_size,
         per_level_min_attempts_for_review,
         force_new_when_below_threshold,
         review_due_first,
         weak_requires_history
  into v_default_count, v_min_attempts, v_force_new, v_review_due_first, v_weak_requires_history
  from policy_thresholds
  order by updated_at desc
  limit 1;

  v_count := coalesce(p_count, v_default_count);

  select coalesce(u.current_level, 1)
  into v_current_level
  from users u
  where u.id = p_user_id;

  select plm.level_weights
  into v_base_level_mix
  from policy_level_mix plm
  where plm.level = v_current_level;

  if v_base_level_mix is null then
    v_base_level_mix := jsonb_build_object(v_current_level::text, 1.0);
  end if;

  select * into v_adjust
  from get_difficulty_adjustment(p_user_id);

  if v_adjust.applied and v_adjust.adjusted_mix is not null then
    v_applied_level_mix := v_adjust.adjusted_mix;
  else
    v_applied_level_mix := v_base_level_mix;
  end if;

  v_applied_level_mix := normalize_level_mix(v_applied_level_mix);

  select ptw.weights
  into v_type_weights
  from policy_type_weights ptw
  where ptw.session_type = p_type;

  if v_type_weights is null then
    v_type_weights := jsonb_build_object('review',0.5,'new',0.3,'weak',0.2);
  end if;

  select coalesce(count(*),0)
  into v_level_attempts
  from attempts a
  join session_items si on si.session_id = a.session_id and si.item_id = a.item_id
  where a.session_id in (select id from sessions where user_id = p_user_id)
    and (si.snapshot_json->>'level')::int = v_current_level;

  if v_force_new and v_level_attempts < v_min_attempts then
    v_effective_type := 'new_only';
  else
    v_effective_type := p_type;
  end if;

  if v_effective_type = 'new_only' then
    tgt_new := v_count;
  else
    tgt_review := floor((coalesce(v_type_weights->>'review','0'))::numeric * v_count)::int;
    tgt_new    := floor((coalesce(v_type_weights->>'new','0'))::numeric    * v_count)::int;
    tgt_weak   := floor((coalesce(v_type_weights->>'weak','0'))::numeric   * v_count)::int;

    while (tgt_review + tgt_new + tgt_weak) < v_count loop
      if v_effective_type = 'review_only' then
        tgt_review := tgt_review + 1;
      elsif v_effective_type = 'weak_focus' then
        tgt_weak := tgt_weak + 1;
      else
        tgt_review := tgt_review + 1;
      end if;
    end loop;
  end if;

  drop table if exists tmp_final_ids;
  create temporary table tmp_final_ids on commit drop as
  with
  lvl as (
    select (key)::int as lvl, (value)::numeric as w
    from jsonb_each(v_applied_level_mix)
    order by 1
  ),
  user_seen as (
    select distinct i.id as item_id
    from items i
    join attempts a on a.item_id = i.id
    join sessions s on s.id = a.session_id
    where s.user_id = p_user_id
  ),
  review_items as (
    select i.id, i.level, i.created_at,
           coalesce(uis.next_due_at, now()) as due_at,
           case when uis.next_due_at <= now() then 1 else 0 end as is_due
    from items i
    join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    where i.status in ('draft','approved')
  ),
  weak_items as (
    select i.id, i.level,
           coalesce(uis.wrong_count,0) + coalesce(ucs.wrong_count,0) as wscore,
           greatest(coalesce(uis.wrong_count,0), coalesce(ucs.wrong_count,0)) as maxw
    from items i
    left join user_item_status uis on uis.item_id = i.id and uis.user_id = p_user_id
    left join user_concept_status ucs on ucs.user_id = p_user_id and ucs.concept_key = i.concept_key
    where i.status in ('draft','approved')
      and (coalesce(uis.total_attempts,0) + coalesce(ucs.total_attempts,0)) > 0
  ),
  new_items as (
    select i.id, i.level, i.created_at
    from items i
    left join user_seen us on us.item_id = i.id
    where i.status in ('draft','approved')
      and us.item_id is null
  ),
  pick_review as (
    select ri.id
    from review_items ri
    join lvl on lvl.lvl = ri.level
    order by (case when v_review_due_first then ri.is_due else 0 end) desc,
             (case when v_review_due_first then ri.due_at else ri.created_at end) asc
    limit tgt_review
  ),
  pick_weak as (
    select wi.id
    from weak_items wi
    join lvl on lvl.lvl = wi.level
    where (not v_weak_requires_history) or wi.maxw > 0
    order by wi.wscore desc, wi.maxw desc
    limit tgt_weak
  ),
  pick_new as (
    select ni.id
    from new_items ni
    join lvl on lvl.lvl = ni.level
    order by ni.created_at desc
    limit tgt_new
  ),
  picked as (
    select id from pick_review
    union all
    select id from pick_weak
    union all
    select id from pick_new
  ),
  picked_dedup as (
    select distinct id from picked
  ),
  fillup as (
    select i.id
    from items i
    left join picked_dedup pd on pd.id = i.id
    join lvl on lvl.lvl = i.level
    where pd.id is null
      and i.status in ('draft','approved')
    order by i.created_at desc
    limit greatest(v_count - (select count(*) from picked_dedup), 0)
  )
  select id
  from (
    select id from picked_dedup
    union all
    select id from fillup
    limit v_count
  ) f;

  select * into v_stats
  from get_user_level_stats(p_user_id);

  insert into public.sessions (user_id, status, target_item_count, started_at, strategy_json)
  values (
    p_user_id,
    'in_progress',
    v_count,
    now(),
    jsonb_build_object(
      'type', v_effective_type::text,
      'targets', jsonb_build_object('review',tgt_review,'weak',tgt_weak,'new',tgt_new),
      'underfilled', (select count(*) from tmp_final_ids) < v_count,
      'filled', (select count(*) from tmp_final_ids),
      'base_level_mix', v_base_level_mix,
      'applied_level_mix', v_applied_level_mix,
      'adjustment', jsonb_build_object(
        'applied', coalesce(v_adjust.applied, false),
        'reason', coalesce(v_adjust.reason, ''),
        'policy_level', v_adjust.policy_level,
        'recent_correct_rate', v_adjust.recent_correct_rate,
        'low_box_concept_count', v_adjust.low_box_concept_count
      ),
      'stats_snapshot', to_jsonb(v_stats)
    )
  )
  returning id into v_session_id;

  insert into public.session_items (session_id, item_id, order_index, snapshot_json)
  select v_session_id,
         i.id,
         row_number() over (order by i.created_at desc) as order_index,
         jsonb_build_object(
           'id', i.id,
           'type', i.type,
           'level', i.level,
           'difficulty', i.difficulty,
           'concept_key', i.concept_key,
           'source_ko', i.source_ko,
           'answer_en', i.answer_en,
           'allowed_variants_text', i.allowed_variants_text,
           'near_misses_text', i.near_misses_text
         )
  from items i
  where i.id in (select id from tmp_final_ids);

  return v_session_id;
end;
$$;
-- start_session_custom: ?•ì±… ê¸°ë°˜?¼ë¡œ ?¸ì…˜ ?ì„± + ?œì´??ì¡°ì • ?•ë³´ ê¸°ë¡
-----------------------
-- 0) ì¤€ë¹? UUID ?ì„±??
create extension if not exists pgcrypto;

-- 1) ê³µí†µ updated_at ?¸ë¦¬ê±?(ì¤‘ë³µ ?ì„± ë°©ì?)
create or replace function public.touch_updated_at()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

-- 2) products: ?ë§¤ ?í’ˆ ?•ì˜
create table if not exists public.products (
  id text primary key,
  display_name text not null,
  list_price_krw integer not null check (list_price_krw >= 0),
  launch_price_krw integer not null check (launch_price_krw >= 0),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger trg_products_updated_at
before update on public.products
for each row execute function public.touch_updated_at();

-- 3) payments: ê²°ì œ ?”ì²­/?‘ë‹µ ?¨ê±´
create table if not exists public.payments (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  provider text not null default 'payapp',
  provider_tx_id text unique,
  amount_krw integer not null check (amount_krw > 0),
  status text not null check (status in ('pending','paid','failed','canceled','refunded')),
  requested_at timestamptz not null default now(),
  paid_at timestamptz,
  canceled_at timestamptz,
  meta_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_payments_user_id on public.payments(user_id);
create index idx_payments_product_id on public.payments(product_id);
create index idx_payments_status on public.payments(status);

create trigger trg_payments_updated_at
before update on public.payments
for each row execute function public.touch_updated_at();

-- 4) payment_events: ?¹í›… ë°??íƒœ ë³€ê²?ë¡œê·¸
create table if not exists public.payment_events (
  id uuid primary key default gen_random_uuid(),
  payment_id uuid not null references public.payments(id) on delete cascade,
  event_type text not null,
  payload_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index idx_payment_events_payment_id on public.payment_events(payment_id);
create index idx_payment_events_event_type on public.payment_events(event_type);

-- 5) entitlements: ?´ìš©ê¶?ê¶Œë¦¬) ?Œì´ë¸?
create table if not exists public.entitlements (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  product_id text not null references public.products(id),
  payment_id uuid not null references public.payments(id) on delete cascade,
  start_at timestamptz not null,
  end_at timestamptz not null,
  is_active boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(payment_id)
);

create index idx_entitlements_user_id on public.entitlements(user_id);
create index idx_entitlements_active on public.entitlements(is_active);
create index idx_entitlements_end_at on public.entitlements(end_at);

-- is_active ê°±ì‹  + users.pro_until ìºì‹œ ë°˜ì˜???¨ìˆ˜/?¸ë¦¬ê±?
create or replace function public.entitlements_after_change()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_latest_until timestamptz;
begin
  -- is_active: start_at <= now() < end_at ì¡°ê±´???°ë¼ ê°±ì‹ 
  if (TG_OP = 'INSERT' or TG_OP = 'UPDATE') then
    if new.start_at <= now() and new.end_at > now() then
      new.is_active := true;
    else
      new.is_active := false;
    end if;
  end if;

  -- ?¬ìš©??pro_until ìºì‹œ ?…ë°?´íŠ¸(? íƒ ?„ë“œê°€ ì¡´ì¬???Œë§Œ)
  begin
    select max(end_at) into v_latest_until
    from public.entitlements
    where user_id = new.user_id;

    update public.users
    set pro_until = v_latest_until
    where id = new.user_id;
  exception when undefined_column then
    -- users.pro_until ì»¬ëŸ¼???†ìœ¼ë©?ë¬´ì‹œ
    null;
  end;

  return new;
end;
$$;

create trigger trg_entitlements_upsert
before insert or update on public.entitlements
for each row execute function public.entitlements_after_change();

create trigger trg_entitlements_updated_at
before update on public.entitlements
for each row execute function public.touch_updated_at();

-- 5-1) users ?Œì´ë¸”ì— pro_until ìºì‹œ ì»¬ëŸ¼ ì¶”ê? (? íƒ)
alter table public.users
  add column if not exists pro_until timestamptz;

-- 6) ?¸ì…˜ ?œì‘ ê°€???¨ìˆ˜ (ë¬´ë£Œ 1??+ ?´ìš©ê¶?ì²´í¬)
create or replace function public.can_start_session(p_user_id uuid)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_today date := (timezone('Asia/Seoul', now()))::date;
  v_completed_today integer;
  v_pro_until timestamptz;
  v_has_entitlement boolean;
  v_can_start boolean := false;
  v_reason text := 'NO_FREE_LEFT';
begin
  -- ?¤ëŠ˜ ?„ë£Œ???¸ì…˜ ??
  select count(*) into v_completed_today
  from public.sessions
  where user_id = p_user_id
    and status = 'completed'
    and (timezone('Asia/Seoul', ended_at))::date = v_today;

  -- ?œì„± ?´ìš©ê¶??¬ë?
  select exists (
    select 1
    from public.entitlements
    where user_id = p_user_id
      and end_at > now()
      and start_at <= now()
  ) into v_has_entitlement;

  -- pro_until ìºì‹œ (?†ìœ¼ë©?null)
  begin
    select pro_until into v_pro_until
    from public.users where id = p_user_id;
  exception when undefined_column then
    v_pro_until := null;
  end;

  if v_has_entitlement or (v_pro_until is not null and v_pro_until > now()) then
    v_can_start := true;
    v_reason := 'OK_WITH_PRO';
  elsif v_completed_today < 1 then
    v_can_start := true;
    v_reason := 'OK_WITH_FREE';
  end if;

  return jsonb_build_object(
    'can_start', v_can_start,
    'reason', v_reason,
    'free_sessions_used_today', v_completed_today,
    'pro_until', v_pro_until
  );
end;
$$;

-- 7) RLS ?•ì±… ?¤ì •
alter table public.products enable row level security;
alter table public.payments enable row level security;
alter table public.payment_events enable row level security;
alter table public.entitlements enable row level security;

-- products: ?„êµ¬??active ?í’ˆë§?ì¡°íšŒ ê°€??? íƒ?ìœ¼ë¡?ê³µê°œ)
drop policy if exists products_select_active on public.products;
create policy products_select_active
on public.products
for select
using (is_active = true);

-- payments: ë³¸ì¸?€ ?ì‹ ??ê²°ì œë§?ì¡°íšŒ
drop policy if exists payments_select_own on public.payments;
create policy payments_select_own
on public.payments
for select
using (auth.uid() = user_id);

-- payment_events: ë³¸ì¸ ê²°ì œ ë¡œê·¸ë§?ì¡°íšŒ
drop policy if exists payment_events_select_own on public.payment_events;
create policy payment_events_select_own
on public.payment_events
for select
using (
  auth.uid() = (
    select user_id from public.payments where id = payment_id
  )
);

-- entitlements: ë³¸ì¸ ê¶Œë¦¬ë§?ì¡°íšŒ
drop policy if exists entitlements_select_own on public.entitlements;
create policy entitlements_select_own
on public.entitlements
for select
using (auth.uid() = user_id);

-- ?œë¹„??ë¡??„ìš© ?„ì²´ ê¶Œí•œ (INSERT/UPDATE/DELETE)
drop policy if exists payments_service_all on public.payments;
create policy payments_service_all
on public.payments
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists payment_events_service_all on public.payment_events;
create policy payment_events_service_all
on public.payment_events
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

drop policy if exists entitlements_service_all on public.entitlements;
create policy entitlements_service_all
on public.entitlements
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- (?„ìš” ?? products ?˜ì •???œë¹„??ë¡¤ë§Œ ?ˆìš©
drop policy if exists products_service_all on public.products;
create policy products_service_all
on public.products
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');
--------------------
